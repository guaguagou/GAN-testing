        -:    0:Source:hyperg_1F1.c
        -:    0:Graph:hyperg_1F1.gcno
        -:    0:Data:hyperg_1F1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/* specfunc/hyperg_1F1.c
        -:    2: * 
        -:    3: * Copyright (C) 1996, 1997, 1998, 1999, 2000 Gerard Jungman
        -:    4: * Copyright (C) 2010 Brian Gough
        -:    5: * 
        -:    6: * This program is free software; you can redistribute it and/or modify
        -:    7: * it under the terms of the GNU General Public License as published by
        -:    8: * the Free Software Foundation; either version 3 of the License, or (at
        -:    9: * your option) any later version.
        -:   10: * 
        -:   11: * This program is distributed in the hope that it will be useful, but
        -:   12: * WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13: * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -:   14: * General Public License for more details.
        -:   15: * 
        -:   16: * You should have received a copy of the GNU General Public License
        -:   17: * along with this program; if not, write to the Free Software
        -:   18: * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
        -:   19: */
        -:   20:
        -:   21:/* Author:  G. Jungman */
        -:   22:
        -:   23://#include <config.h>
        -:   24:#include <gsl/gsl_math.h>
        -:   25:#include <gsl/gsl_errno.h>
        -:   26:#include <gsl/gsl_sf_elementary.h>
        -:   27:#include <gsl/gsl_sf_exp.h>
        -:   28:#include <gsl/gsl_sf_bessel.h>
        -:   29:#include <gsl/gsl_sf_gamma.h>
        -:   30:#include <gsl/gsl_sf_laguerre.h>
        -:   31:#include <gsl/gsl_sf_hyperg.h>
        -:   32:#include <stdlib.h>
        -:   33:#include <stdio.h>
        -:   34:#include <string.h>
        -:   35:
        -:   36:#include "../../gsl-2.6/specfunc/error.h"
        -:   37:#include "../../gsl-2.6/specfunc/hyperg.h"
        -:   38:
        -:   39:#define _1F1_INT_THRESHOLD (100.0*GSL_DBL_EPSILON)
        -:   40:
        -:   41:
        -:   42:/* Asymptotic result for 1F1(a, b, x)  x -> -Infinity.
        -:   43: * Assumes b-a != neg integer and b != neg integer.
        -:   44: */
        -:   45:static
        -:   46:int
function hyperg_1F1_asymp_negx called 0 returned 0% blocks executed 0%
    #####:   47:hyperg_1F1_asymp_negx(const double a, const double b, const double x,
        -:   48:                     gsl_sf_result * result)
        -:   49:{
        -:   50:  gsl_sf_result lg_b;
        -:   51:  gsl_sf_result lg_bma;
        -:   52:  double sgn_b;
        -:   53:  double sgn_bma;
        -:   54:
    #####:   55:  int stat_b   = gsl_sf_lngamma_sgn_e(b,   &lg_b,   &sgn_b);
    #####:   56:  int stat_bma = gsl_sf_lngamma_sgn_e(b-a, &lg_bma, &sgn_bma);
        -:   57:
    #####:   58:  if(stat_b == GSL_SUCCESS && stat_bma == GSL_SUCCESS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   59:    gsl_sf_result F;
    #####:   60:    int stat_F = gsl_sf_hyperg_2F0_series_e(a, 1.0+a-b, -1.0/x, -1, &F);
    #####:   61:    if(F.val != 0) {
branch  0 never executed
branch  1 never executed
    #####:   62:      double ln_term_val = a*log(-x);
    #####:   63:      double ln_term_err = 2.0 * GSL_DBL_EPSILON * (fabs(a) + fabs(ln_term_val));
    #####:   64:      double ln_pre_val = lg_b.val - lg_bma.val - ln_term_val;
    #####:   65:      double ln_pre_err = lg_b.err + lg_bma.err + ln_term_err;
    #####:   66:      int stat_e = gsl_sf_exp_mult_err_e(ln_pre_val, ln_pre_err,
    #####:   67:                                            sgn_bma*sgn_b*F.val, F.err,
    #####:   68:                                            result);
    #####:   69:      return GSL_ERROR_SELECT_2(stat_e, stat_F);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:   70:    }
        -:   71:    else {
    #####:   72:      result->val = 0.0;
    #####:   73:      result->err = 0.0;
    #####:   74:      return stat_F;
        -:   75:    }
        -:   76:  }
        -:   77:  else {
    #####:   78:    DOMAIN_ERROR(result);
        -:   79:  }
    #####:   80:}
        -:   81:
        -:   82:
        -:   83:/* Asymptotic result for 1F1(a, b, x)  x -> +Infinity
        -:   84: * Assumes b != neg integer and a != neg integer
        -:   85: */
        -:   86:static
        -:   87:int
function hyperg_1F1_asymp_posx called 0 returned 0% blocks executed 0%
    #####:   88:hyperg_1F1_asymp_posx(const double a, const double b, const double x,
        -:   89:                      gsl_sf_result * result)
        -:   90:{
        -:   91:  gsl_sf_result lg_b;
        -:   92:  gsl_sf_result lg_a;
        -:   93:  double sgn_b;
        -:   94:  double sgn_a;
        -:   95:
    #####:   96:  int stat_b = gsl_sf_lngamma_sgn_e(b, &lg_b, &sgn_b);
    #####:   97:  int stat_a = gsl_sf_lngamma_sgn_e(a, &lg_a, &sgn_a);
        -:   98:
    #####:   99:  if(stat_a == GSL_SUCCESS && stat_b == GSL_SUCCESS) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  100:    gsl_sf_result F;
    #####:  101:    int stat_F = gsl_sf_hyperg_2F0_series_e(b-a, 1.0-a, 1.0/x, -1, &F);
    #####:  102:    if(stat_F == GSL_SUCCESS && F.val != 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  103:      double lnx = log(x);
    #####:  104:      double ln_term_val = (a-b)*lnx;
    #####:  105:      double ln_term_err = 2.0 * GSL_DBL_EPSILON * (fabs(a) + fabs(b)) * fabs(lnx)
    #####:  106:                         + 2.0 * GSL_DBL_EPSILON * fabs(a-b);
    #####:  107:      double ln_pre_val = lg_b.val - lg_a.val + ln_term_val + x;
    #####:  108:      double ln_pre_err = lg_b.err + lg_a.err + ln_term_err + 2.0 * GSL_DBL_EPSILON * fabs(x);
    #####:  109:      int stat_e = gsl_sf_exp_mult_err_e(ln_pre_val, ln_pre_err,
    #####:  110:                                            sgn_a*sgn_b*F.val, F.err,
    #####:  111:                                            result);
    #####:  112:      return GSL_ERROR_SELECT_2(stat_e, stat_F);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  113:    }
        -:  114:    else {
    #####:  115:      result->val = 0.0;
    #####:  116:      result->err = 0.0;
    #####:  117:      return stat_F;
        -:  118:    }
        -:  119:  }
        -:  120:  else {
    #####:  121:    DOMAIN_ERROR(result);
        -:  122:  }
    #####:  123:}
        -:  124:
        -:  125:/* Asymptotic result from Slater 4.3.7 
        -:  126: * 
        -:  127: * To get the general series, write M(a,b,x) as
        -:  128: *
        -:  129: *  M(a,b,x)=sum ((a)_n/(b)_n) (x^n / n!)
        -:  130: *
        -:  131: * and expand (b)_n in inverse powers of b as follows
        -:  132: *
        -:  133: * -log(1/(b)_n) = sum_(k=0)^(n-1) log(b+k)
        -:  134: *             = n log(b) + sum_(k=0)^(n-1) log(1+k/b)
        -:  135: *
        -:  136: * Do a taylor expansion of the log in 1/b and sum the resulting terms
        -:  137: * using the standard algebraic formulas for finite sums of powers of
        -:  138: * k.  This should then give
        -:  139: *
        -:  140: * M(a,b,x) = sum_(n=0)^(inf) (a_n/n!) (x/b)^n * (1 - n(n-1)/(2b) 
        -:  141: *                          + (n-1)n(n+1)(3n-2)/(24b^2) + ...
        -:  142: *
        -:  143: * which can be summed explicitly. The trick for summing it is to take
        -:  144: * derivatives of sum_(i=0)^(inf) a_n*y^n/n! = (1-y)^(-a);
        -:  145: *
        -:  146: * [BJG 16/01/2007]
        -:  147: */
        -:  148:
        -:  149:static 
        -:  150:int
function hyperg_1F1_largebx called 0 returned 0% blocks executed 0%
    #####:  151:hyperg_1F1_largebx(const double a, const double b, const double x, gsl_sf_result * result)
        -:  152:{
    #####:  153:  double y = x/b;
    #####:  154:  double f = exp(-a*log1p(-y));
    #####:  155:  double t1 = -((a*(a+1.0))/(2*b))*pow((y/(1.0-y)),2.0);
    #####:  156:  double t2 = (1/(24*b*b))*((a*(a+1)*y*y)/pow(1-y,4))*(12+8*(2*a+1)*y+(3*a*a-a-2)*y*y);
    #####:  157:  double t3 = (-1/(48*b*b*b*pow(1-y,6)))*a*((a + 1)*((y*((a + 1)*(a*(y*(y*((y*(a - 2) + 16)*(a - 1)) + 72)) + 96)) + 24)*pow(y, 2)));
    #####:  158:  result->val = f * (1 + t1 + t2 + t3);
    #####:  159:  result->err = 2*fabs(f*t3) + 2*GSL_DBL_EPSILON*fabs(result->val);
    #####:  160:  return GSL_SUCCESS;
        -:  161:}
        -:  162: 
        -:  163:/* Asymptotic result for x < 2b-4a, 2b-4a large.
        -:  164: * [Abramowitz+Stegun, 13.5.21]
        -:  165: *
        -:  166: * assumes 0 <= x/(2b-4a) <= 1
        -:  167: */
        -:  168:static
        -:  169:int
function hyperg_1F1_large2bm4a called 0 returned 0% blocks executed 0%
    #####:  170:hyperg_1F1_large2bm4a(const double a, const double b, const double x, gsl_sf_result * result)
        -:  171:{
    #####:  172:  double eta    = 2.0*b - 4.0*a;
    #####:  173:  double cos2th = x/eta;
    #####:  174:  double sin2th = 1.0 - cos2th;
    #####:  175:  double th = acos(sqrt(cos2th));
    #####:  176:  double pre_h  = 0.25*M_PI*M_PI*eta*eta*cos2th*sin2th;
        -:  177:  gsl_sf_result lg_b;
    #####:  178:  int stat_lg = gsl_sf_lngamma_e(b, &lg_b);
    #####:  179:  double t1 = 0.5*(1.0-b)*log(0.25*x*eta);
    #####:  180:  double t2 = 0.25*log(pre_h);
    #####:  181:  double lnpre_val = lg_b.val + 0.5*x + t1 - t2;
    #####:  182:  double lnpre_err = lg_b.err + 2.0 * GSL_DBL_EPSILON * (fabs(0.5*x) + fabs(t1) + fabs(t2));
        -:  183:#if SMALL_ANGLE
        -:  184:  const double eps = asin(sqrt(cos2th));  /* theta = pi/2 - eps */
        -:  185:  double s1 = (fmod(a, 1.0) == 0.0) ? 0.0 : sin(a*M_PI);
        -:  186:  double eta_reduc = (fmod(eta + 1, 4.0) == 0.0) ? 0.0 : fmod(eta + 1, 8.0);
        -:  187:  double phi1 = 0.25*eta_reduc*M_PI;
        -:  188:  double phi2 = 0.25*eta*(2*eps + sin(2.0*eps));
        -:  189:  double s2 = sin(phi1 - phi2);
        -:  190:#else
    #####:  191:  double s1 = sin(a*M_PI);
    #####:  192:  double s2 = sin(0.25*eta*(2.0*th - sin(2.0*th)) + 0.25*M_PI);
        -:  193:#endif
    #####:  194:  double ser_val = s1 + s2;
    #####:  195:  double ser_err = 2.0 * GSL_DBL_EPSILON * (fabs(s1) + fabs(s2));
    #####:  196:  int stat_e = gsl_sf_exp_mult_err_e(lnpre_val, lnpre_err,
    #####:  197:                                        ser_val, ser_err,
    #####:  198:                                        result);
    #####:  199:  return GSL_ERROR_SELECT_2(stat_e, stat_lg);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  200:}
        -:  201:
        -:  202:
        -:  203:/* Luke's rational approximation.
        -:  204: * See [Luke, Algorithms for the Computation of Mathematical Functions, p.182]
        -:  205: *
        -:  206: * Like the case of the 2F1 rational approximations, these are
        -:  207: * probably guaranteed to converge for x < 0, barring gross
        -:  208: * numerical instability in the pre-asymptotic regime.
        -:  209: */
        -:  210:static
        -:  211:int
function hyperg_1F1_luke called 0 returned 0% blocks executed 0%
    #####:  212:hyperg_1F1_luke(const double a, const double c, const double xin,
        -:  213:                gsl_sf_result * result)
        -:  214:{
    #####:  215:  const double RECUR_BIG = 1.0e+50;
    #####:  216:  const int nmax = 5000;
    #####:  217:  int n = 3;
    #####:  218:  const double x  = -xin;
    #####:  219:  const double x3 = x*x*x;
    #####:  220:  const double t0 = a/c;
    #####:  221:  const double t1 = (a+1.0)/(2.0*c);
    #####:  222:  const double t2 = (a+2.0)/(2.0*(c+1.0));
    #####:  223:  double F = 1.0;
        -:  224:  double prec;
        -:  225:
    #####:  226:  double Bnm3 = 1.0;                                  /* B0 */
    #####:  227:  double Bnm2 = 1.0 + t1 * x;                         /* B1 */
    #####:  228:  double Bnm1 = 1.0 + t2 * x * (1.0 + t1/3.0 * x);    /* B2 */
        -:  229: 
    #####:  230:  double Anm3 = 1.0;                                                      /* A0 */
    #####:  231:  double Anm2 = Bnm2 - t0 * x;                                            /* A1 */
    #####:  232:  double Anm1 = Bnm1 - t0*(1.0 + t2*x)*x + t0 * t1 * (c/(c+1.0)) * x*x;   /* A2 */
        -:  233:
    #####:  234:  while(1) {
    #####:  235:    double npam1 = n + a - 1;
    #####:  236:    double npcm1 = n + c - 1;
    #####:  237:    double npam2 = n + a - 2;
    #####:  238:    double npcm2 = n + c - 2;
    #####:  239:    double tnm1  = 2*n - 1;
    #####:  240:    double tnm3  = 2*n - 3;
    #####:  241:    double tnm5  = 2*n - 5;
    #####:  242:    double F1 =  (n-a-2) / (2*tnm3*npcm1);
    #####:  243:    double F2 =  (n+a)*npam1 / (4*tnm1*tnm3*npcm2*npcm1);
    #####:  244:    double F3 = -npam2*npam1*(n-a-2) / (8*tnm3*tnm3*tnm5*(n+c-3)*npcm2*npcm1);
    #####:  245:    double E  = -npam1*(n-c-1) / (2*tnm3*npcm2*npcm1);
        -:  246:
    #####:  247:    double An = (1.0+F1*x)*Anm1 + (E + F2*x)*x*Anm2 + F3*x3*Anm3;
    #####:  248:    double Bn = (1.0+F1*x)*Bnm1 + (E + F2*x)*x*Bnm2 + F3*x3*Bnm3;
    #####:  249:    double r = An/Bn;
        -:  250:
    #####:  251:    prec = fabs((F - r)/F);
    #####:  252:    F = r;
        -:  253:
    #####:  254:    if(prec < GSL_DBL_EPSILON || n > nmax) break;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  255:
    #####:  256:    if(fabs(An) > RECUR_BIG || fabs(Bn) > RECUR_BIG) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  257:      An   /= RECUR_BIG;
    #####:  258:      Bn   /= RECUR_BIG;
    #####:  259:      Anm1 /= RECUR_BIG;
    #####:  260:      Bnm1 /= RECUR_BIG;
    #####:  261:      Anm2 /= RECUR_BIG;
    #####:  262:      Bnm2 /= RECUR_BIG;
    #####:  263:      Anm3 /= RECUR_BIG;
    #####:  264:      Bnm3 /= RECUR_BIG;
    #####:  265:    }
    #####:  266:    else if(fabs(An) < 1.0/RECUR_BIG || fabs(Bn) < 1.0/RECUR_BIG) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  267:      An   *= RECUR_BIG;
    #####:  268:      Bn   *= RECUR_BIG;
    #####:  269:      Anm1 *= RECUR_BIG;
    #####:  270:      Bnm1 *= RECUR_BIG;
    #####:  271:      Anm2 *= RECUR_BIG;
    #####:  272:      Bnm2 *= RECUR_BIG;
    #####:  273:      Anm3 *= RECUR_BIG;
    #####:  274:      Bnm3 *= RECUR_BIG;
    #####:  275:    }
        -:  276:
    #####:  277:    n++;
    #####:  278:    Bnm3 = Bnm2;
    #####:  279:    Bnm2 = Bnm1;
    #####:  280:    Bnm1 = Bn;
    #####:  281:    Anm3 = Anm2;
    #####:  282:    Anm2 = Anm1;
    #####:  283:    Anm1 = An;
        -:  284:  }
        -:  285:
    #####:  286:  result->val  = F;
    #####:  287:  result->err  = 2.0 * fabs(F * prec);
    #####:  288:  result->err += 2.0 * GSL_DBL_EPSILON * (n-1.0) * fabs(F);
        -:  289:
    #####:  290:  return GSL_SUCCESS;
        -:  291:}
        -:  292:
        -:  293:/* Series for 1F1(1,b,x)
        -:  294: * b > 0
        -:  295: */
        -:  296:static
        -:  297:int
function hyperg_1F1_1_series called 0 returned 0% blocks executed 0%
    #####:  298:hyperg_1F1_1_series(const double b, const double x, gsl_sf_result * result)
        -:  299:{
    #####:  300:  double sum_val = 1.0;
    #####:  301:  double sum_err = 0.0;
    #####:  302:  double term = 1.0;
    #####:  303:  double n    = 1.0;
    #####:  304:  while(fabs(term/sum_val) > 0.25*GSL_DBL_EPSILON) {
branch  0 never executed
branch  1 never executed
    #####:  305:    term *= x/(b+n-1);
    #####:  306:    sum_val += term;
    #####:  307:    sum_err += 8.0*GSL_DBL_EPSILON*fabs(term) + GSL_DBL_EPSILON*fabs(sum_val);
    #####:  308:    n += 1.0;
        -:  309:  }
    #####:  310:  result->val  = sum_val;
    #####:  311:  result->err  = sum_err;
    #####:  312:  result->err += 2.0 *  fabs(term);
    #####:  313:  return GSL_SUCCESS;
        -:  314:}
        -:  315:
        -:  316:
        -:  317:/* 1F1(1,b,x)
        -:  318: * b >= 1, b integer
        -:  319: */
        -:  320:static
        -:  321:int
function hyperg_1F1_1_int called 0 returned 0% blocks executed 0%
    #####:  322:hyperg_1F1_1_int(const int b, const double x, gsl_sf_result * result)
        -:  323:{
    #####:  324:  if(b < 1) {
branch  0 never executed
branch  1 never executed
    #####:  325:    DOMAIN_ERROR(result);
    #####:  326:  }
    #####:  327:  else if(b == 1) {
branch  0 never executed
branch  1 never executed
    #####:  328:    return gsl_sf_exp_e(x, result);
        -:  329:  }
    #####:  330:  else if(b == 2) {
branch  0 never executed
branch  1 never executed
    #####:  331:    return gsl_sf_exprel_e(x, result);
        -:  332:  }
    #####:  333:  else if(b == 3) {
branch  0 never executed
branch  1 never executed
    #####:  334:    return gsl_sf_exprel_2_e(x, result);
        -:  335:  }
        -:  336:  else {
    #####:  337:    return gsl_sf_exprel_n_e(b-1, x, result);
        -:  338:  }
    #####:  339:}
        -:  340:
        -:  341:
        -:  342:/* 1F1(1,b,x)
        -:  343: * b >=1, b real
        -:  344: *
        -:  345: * checked OK: [GJ] Thu Oct  1 16:46:35 MDT 1998
        -:  346: */
        -:  347:static
        -:  348:int
function hyperg_1F1_1 called 0 returned 0% blocks executed 0%
    #####:  349:hyperg_1F1_1(const double b, const double x, gsl_sf_result * result)
        -:  350:{
    #####:  351:  double ax = fabs(x);
    #####:  352:  double ib = floor(b + 0.1);
        -:  353:
    #####:  354:  if(b < 1.0) {
branch  0 never executed
branch  1 never executed
    #####:  355:    DOMAIN_ERROR(result);
    #####:  356:  }
    #####:  357:  else if(b == 1.0) {
branch  0 never executed
branch  1 never executed
    #####:  358:    return gsl_sf_exp_e(x, result);
        -:  359:  }
    #####:  360:  else if(b >= 1.4*ax) {
branch  0 never executed
branch  1 never executed
    #####:  361:    return hyperg_1F1_1_series(b, x, result);
        -:  362:  }
    #####:  363:  else if(fabs(b - ib) < _1F1_INT_THRESHOLD && ib < INT_MAX) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  364:    return hyperg_1F1_1_int((int)ib, x, result);
        -:  365:  }
    #####:  366:  else if(x > 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  367:    if(x > 100.0 && b < 0.75*x) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  368:      return hyperg_1F1_asymp_posx(1.0, b, x, result);
        -:  369:    }
    #####:  370:    else if(b < 1.0e+05) {
branch  0 never executed
branch  1 never executed
        -:  371:      /* Recurse backward on b, from a
        -:  372:       * chosen offset point. For x > 0,
        -:  373:       * which holds here, this should
        -:  374:       * be a stable direction.
        -:  375:       */
    #####:  376:      const double off = ceil(1.4*x-b) + 1.0;
    #####:  377:      double bp = b + off;
        -:  378:      gsl_sf_result M;
    #####:  379:      int stat_s = hyperg_1F1_1_series(bp, x, &M);
    #####:  380:      const double err_rat = M.err / fabs(M.val);
    #####:  381:      while(bp > b+0.1) {
branch  0 never executed
branch  1 never executed
        -:  382:        /* M(1,b-1) = x/(b-1) M(1,b) + 1 */
    #####:  383:        bp -= 1.0;
    #####:  384:        M.val  = 1.0 + x/bp * M.val;
        -:  385:      }
    #####:  386:      result->val  = M.val;
    #####:  387:      result->err  = err_rat * fabs(M.val);
    #####:  388:      result->err += 2.0 * GSL_DBL_EPSILON * (fabs(off)+1.0) * fabs(M.val);
    #####:  389:      return stat_s;
    #####:  390:    } else if (fabs(x) < fabs(b) && fabs(x) < sqrt(fabs(b)) * fabs(b-x)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  391:      return hyperg_1F1_largebx(1.0, b, x, result);
    #####:  392:    } else if (fabs(x) > fabs(b)) {
branch  0 never executed
branch  1 never executed
    #####:  393:      return hyperg_1F1_1_series(b, x, result);
        -:  394:    } else {
    #####:  395:      return hyperg_1F1_large2bm4a(1.0, b, x, result);
        -:  396:    }
        -:  397:  }
        -:  398:  else {
        -:  399:    /* x <= 0 and b not large compared to |x|
        -:  400:     */
    #####:  401:    if(ax < 10.0 && b < 10.0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  402:      return hyperg_1F1_1_series(b, x, result);
        -:  403:    }
    #####:  404:    else if(ax >= 100.0 && GSL_MAX_DBL(fabs(2.0-b),1.0) < 0.99*ax) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  405:      return hyperg_1F1_asymp_negx(1.0, b, x, result);
        -:  406:    }
        -:  407:    else {
    #####:  408:      return hyperg_1F1_luke(1.0, b, x, result);
        -:  409:    }
        -:  410:  }
    #####:  411:}
        -:  412:
        -:  413:
        -:  414:/* 1F1(a,b,x)/Gamma(b) for b->0
        -:  415: * [limit of Abramowitz+Stegun 13.3.7]
        -:  416: */
        -:  417:static
        -:  418:int
function hyperg_1F1_renorm_b0 called 0 returned 0% blocks executed 0%
    #####:  419:hyperg_1F1_renorm_b0(const double a, const double x, gsl_sf_result * result)
        -:  420:{
    #####:  421:  double eta = a*x;
    #####:  422:  if(eta > 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  423:    double root_eta = sqrt(eta);
        -:  424:    gsl_sf_result I1_scaled;
    #####:  425:    int stat_I = gsl_sf_bessel_I1_scaled_e(2.0*root_eta, &I1_scaled);
    #####:  426:    if(I1_scaled.val <= 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  427:      result->val = 0.0;
    #####:  428:      result->err = 0.0;
    #####:  429:      return GSL_ERROR_SELECT_2(stat_I, GSL_EDOM);
branch  0 never executed
branch  1 never executed
        -:  430:    }
        -:  431:    else {
        -:  432:      /* Note that 13.3.7 contains higher terms which are zeroth order
        -:  433:         in b.  These make a non-negligible contribution to the sum.
        -:  434:         With the first correction term, the I1 above is replaced by
        -:  435:         I1 + (2/3)*a*(x/(4a))**(3/2)*I2(2*root_eta).  We will add
        -:  436:         this as part of the result and error estimate. */
        -:  437:
    #####:  438:      const double corr1 =(2.0/3.0)*a*pow(x/(4.0*a),1.5)*gsl_sf_bessel_In_scaled(2, 2.0*root_eta)
        -:  439: ;
    #####:  440:      const double lnr_val = 0.5*x + 0.5*log(eta) + fabs(2.0*root_eta) + log(I1_scaled.val+corr1);
    #####:  441:      const double lnr_err = GSL_DBL_EPSILON * (1.5*fabs(x) + 1.0) + fabs((I1_scaled.err+corr1)/I1_scaled.val);
    #####:  442:      return gsl_sf_exp_err_e(lnr_val, lnr_err, result);
        -:  443:    }
        -:  444:  }
    #####:  445:  else if(eta == 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  446:    result->val = 0.0;
    #####:  447:    result->err = 0.0;
    #####:  448:    return GSL_SUCCESS;
        -:  449:  }
        -:  450:  else {
        -:  451:    /* eta < 0 */
    #####:  452:    double root_eta = sqrt(-eta);
        -:  453:    gsl_sf_result J1;
    #####:  454:    int stat_J = gsl_sf_bessel_J1_e(2.0*root_eta, &J1);
    #####:  455:    if(J1.val <= 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  456:      result->val = 0.0;
    #####:  457:      result->err = 0.0;
    #####:  458:      return GSL_ERROR_SELECT_2(stat_J, GSL_EDOM);
branch  0 never executed
branch  1 never executed
        -:  459:    }
        -:  460:    else {
    #####:  461:      const double t1 = 0.5*x;
    #####:  462:      const double t2 = 0.5*log(-eta);
    #####:  463:      const double t3 = fabs(x);
    #####:  464:      const double t4 = log(J1.val);
    #####:  465:      const double lnr_val = t1 + t2 + t3 + t4;
    #####:  466:      const double lnr_err = GSL_DBL_EPSILON * (1.5*fabs(x) + 1.0) + fabs(J1.err/J1.val);
        -:  467:      gsl_sf_result ex;
    #####:  468:      int stat_e = gsl_sf_exp_err_e(lnr_val, lnr_err, &ex);
    #####:  469:      result->val = -ex.val;
    #####:  470:      result->err =  ex.err;
    #####:  471:      return stat_e;
        -:  472:    }
        -:  473:  }
        -:  474:  
    #####:  475:}
        -:  476:
        -:  477:
        -:  478:/* 1F1'(a,b,x)/1F1(a,b,x)
        -:  479: * Uses Gautschi's version of the CF.
        -:  480: * [Gautschi, Math. Comp. 31, 994 (1977)]
        -:  481: *
        -:  482: * Supposedly this suffers from the "anomalous convergence"
        -:  483: * problem when b < x. I have seen anomalous convergence
        -:  484: * in several of the continued fractions associated with
        -:  485: * 1F1(a,b,x). This particular CF formulation seems stable
        -:  486: * for b > x. However, it does display a painful artifact
        -:  487: * of the anomalous convergence; the convergence plateaus
        -:  488: * unless b >>> x. For example, even for b=1000, x=1, this
        -:  489: * method locks onto a ratio which is only good to about
        -:  490: * 4 digits. Apparently the rest of the digits are hiding
        -:  491: * way out on the plateau, but finite-precision lossage
        -:  492: * means you will never get them.
        -:  493: */
        -:  494:#if 0
        -:  495:static
        -:  496:int
        -:  497:hyperg_1F1_CF1_p(const double a, const double b, const double x, double * result)
        -:  498:{
        -:  499:  const double RECUR_BIG = GSL_SQRT_DBL_MAX;
        -:  500:  const int maxiter = 5000;
        -:  501:  int n = 1;
        -:  502:  double Anm2 = 1.0;
        -:  503:  double Bnm2 = 0.0;
        -:  504:  double Anm1 = 0.0;
        -:  505:  double Bnm1 = 1.0;
        -:  506:  double a1 = 1.0;
        -:  507:  double b1 = 1.0;
        -:  508:  double An = b1*Anm1 + a1*Anm2;
        -:  509:  double Bn = b1*Bnm1 + a1*Bnm2;
        -:  510:  double an, bn;
        -:  511:  double fn = An/Bn;
        -:  512:
        -:  513:  while(n < maxiter) {
        -:  514:    double old_fn;
        -:  515:    double del;
        -:  516:    n++;
        -:  517:    Anm2 = Anm1;
        -:  518:    Bnm2 = Bnm1;
        -:  519:    Anm1 = An;
        -:  520:    Bnm1 = Bn;
        -:  521:    an = (a+n)*x/((b-x+n-1)*(b-x+n));
        -:  522:    bn = 1.0;
        -:  523:    An = bn*Anm1 + an*Anm2;
        -:  524:    Bn = bn*Bnm1 + an*Bnm2;
        -:  525:
        -:  526:    if(fabs(An) > RECUR_BIG || fabs(Bn) > RECUR_BIG) {
        -:  527:      An /= RECUR_BIG;
        -:  528:      Bn /= RECUR_BIG;
        -:  529:      Anm1 /= RECUR_BIG;
        -:  530:      Bnm1 /= RECUR_BIG;
        -:  531:      Anm2 /= RECUR_BIG;
        -:  532:      Bnm2 /= RECUR_BIG;
        -:  533:    }
        -:  534:
        -:  535:    old_fn = fn;
        -:  536:    fn = An/Bn;
        -:  537:    del = old_fn/fn;
        -:  538:    
        -:  539:    if(fabs(del - 1.0) < 10.0*GSL_DBL_EPSILON) break;
        -:  540:  }
        -:  541:
        -:  542:  *result = a/(b-x) * fn;
        -:  543:
        -:  544:  if(n == maxiter)
        -:  545:    GSL_ERROR ("error", GSL_EMAXITER);
        -:  546:  else
        -:  547:    return GSL_SUCCESS;
        -:  548:}
        -:  549:#endif /* 0 */
        -:  550:
        -:  551:
        -:  552:/* 1F1'(a,b,x)/1F1(a,b,x)
        -:  553: * Uses Gautschi's series transformation of the
        -:  554: * continued fraction. This is apparently the best
        -:  555: * method for getting this ratio in the stable region.
        -:  556: * The convergence is monotone and supergeometric
        -:  557: * when b > x.
        -:  558: * Assumes a >= -1.
        -:  559: */
        -:  560:static
        -:  561:int
function hyperg_1F1_CF1_p_ser called 0 returned 0% blocks executed 0%
    #####:  562:hyperg_1F1_CF1_p_ser(const double a, const double b, const double x, double * result)
        -:  563:{
    #####:  564:  if(a == 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  565:    *result = 0.0;
    #####:  566:    return GSL_SUCCESS;
        -:  567:  }
        -:  568:  else {
    #####:  569:    const int maxiter = 5000;
    #####:  570:    double sum  = 1.0;
    #####:  571:    double pk   = 1.0;
    #####:  572:    double rhok = 0.0;
        -:  573:    int k;
    #####:  574:    for(k=1; k<maxiter; k++) {
branch  0 never executed
branch  1 never executed
    #####:  575:      double ak = (a + k)*x/((b-x+k-1.0)*(b-x+k));
    #####:  576:      rhok = -ak*(1.0 + rhok)/(1.0 + ak*(1.0+rhok));
    #####:  577:      pk  *= rhok;
    #####:  578:      sum += pk;
    #####:  579:      if(fabs(pk/sum) < 2.0*GSL_DBL_EPSILON) break;
branch  0 never executed
branch  1 never executed
    #####:  580:    }
    #####:  581:    *result = a/(b-x) * sum;
    #####:  582:    if(k == maxiter)
branch  0 never executed
branch  1 never executed
    #####:  583:      GSL_ERROR ("error", GSL_EMAXITER);
        -:  584:    else
    #####:  585:      return GSL_SUCCESS;
        -:  586:  }
    #####:  587:}
        -:  588:
        -:  589:
        -:  590:/* 1F1(a+1,b,x)/1F1(a,b,x)
        -:  591: *
        -:  592: * I think this suffers from typical "anomalous convergence".
        -:  593: * I could not find a region where it was truly useful.
        -:  594: */
        -:  595:#if 0
        -:  596:static
        -:  597:int
        -:  598:hyperg_1F1_CF1(const double a, const double b, const double x, double * result)
        -:  599:{
        -:  600:  const double RECUR_BIG = GSL_SQRT_DBL_MAX;
        -:  601:  const int maxiter = 5000;
        -:  602:  int n = 1;
        -:  603:  double Anm2 = 1.0;
        -:  604:  double Bnm2 = 0.0;
        -:  605:  double Anm1 = 0.0;
        -:  606:  double Bnm1 = 1.0;
        -:  607:  double a1 = b - a - 1.0;
        -:  608:  double b1 = b - x - 2.0*(a+1.0);
        -:  609:  double An = b1*Anm1 + a1*Anm2;
        -:  610:  double Bn = b1*Bnm1 + a1*Bnm2;
        -:  611:  double an, bn;
        -:  612:  double fn = An/Bn;
        -:  613:
        -:  614:  while(n < maxiter) {
        -:  615:    double old_fn;
        -:  616:    double del;
        -:  617:    n++;
        -:  618:    Anm2 = Anm1;
        -:  619:    Bnm2 = Bnm1;
        -:  620:    Anm1 = An;
        -:  621:    Bnm1 = Bn;
        -:  622:    an = (a + n - 1.0) * (b - a - n);
        -:  623:    bn = b - x - 2.0*(a+n);
        -:  624:    An = bn*Anm1 + an*Anm2;
        -:  625:    Bn = bn*Bnm1 + an*Bnm2;
        -:  626:
        -:  627:    if(fabs(An) > RECUR_BIG || fabs(Bn) > RECUR_BIG) {
        -:  628:      An /= RECUR_BIG;
        -:  629:      Bn /= RECUR_BIG;
        -:  630:      Anm1 /= RECUR_BIG;
        -:  631:      Bnm1 /= RECUR_BIG;
        -:  632:      Anm2 /= RECUR_BIG;
        -:  633:      Bnm2 /= RECUR_BIG;
        -:  634:    }
        -:  635:
        -:  636:    old_fn = fn;
        -:  637:    fn = An/Bn;
        -:  638:    del = old_fn/fn;
        -:  639:    
        -:  640:    if(fabs(del - 1.0) < 10.0*GSL_DBL_EPSILON) break;
        -:  641:  }
        -:  642:
        -:  643:  *result = fn;
        -:  644:  if(n == maxiter)
        -:  645:    GSL_ERROR ("error", GSL_EMAXITER);
        -:  646:  else
        -:  647:    return GSL_SUCCESS;
        -:  648:}
        -:  649:#endif /* 0 */
        -:  650:
        -:  651:
        -:  652:/* 1F1(a,b+1,x)/1F1(a,b,x)
        -:  653: *
        -:  654: * This seemed to suffer from "anomalous convergence".
        -:  655: * However, I have no theory for this recurrence.
        -:  656: */
        -:  657:#if 0
        -:  658:static
        -:  659:int
        -:  660:hyperg_1F1_CF1_b(const double a, const double b, const double x, double * result)
        -:  661:{
        -:  662:  const double RECUR_BIG = GSL_SQRT_DBL_MAX;
        -:  663:  const int maxiter = 5000;
        -:  664:  int n = 1;
        -:  665:  double Anm2 = 1.0;
        -:  666:  double Bnm2 = 0.0;
        -:  667:  double Anm1 = 0.0;
        -:  668:  double Bnm1 = 1.0;
        -:  669:  double a1 = b + 1.0;
        -:  670:  double b1 = (b + 1.0) * (b - x);
        -:  671:  double An = b1*Anm1 + a1*Anm2;
        -:  672:  double Bn = b1*Bnm1 + a1*Bnm2;
        -:  673:  double an, bn;
        -:  674:  double fn = An/Bn;
        -:  675:
        -:  676:  while(n < maxiter) {
        -:  677:    double old_fn;
        -:  678:    double del;
        -:  679:    n++;
        -:  680:    Anm2 = Anm1;
        -:  681:    Bnm2 = Bnm1;
        -:  682:    Anm1 = An;
        -:  683:    Bnm1 = Bn;
        -:  684:    an = (b + n) * (b + n - 1.0 - a) * x;
        -:  685:    bn = (b + n) * (b + n - 1.0 - x);
        -:  686:    An = bn*Anm1 + an*Anm2;
        -:  687:    Bn = bn*Bnm1 + an*Bnm2;
        -:  688:
        -:  689:    if(fabs(An) > RECUR_BIG || fabs(Bn) > RECUR_BIG) {
        -:  690:      An /= RECUR_BIG;
        -:  691:      Bn /= RECUR_BIG;
        -:  692:      Anm1 /= RECUR_BIG;
        -:  693:      Bnm1 /= RECUR_BIG;
        -:  694:      Anm2 /= RECUR_BIG;
        -:  695:      Bnm2 /= RECUR_BIG;
        -:  696:    }
        -:  697:
        -:  698:    old_fn = fn;
        -:  699:    fn = An/Bn;
        -:  700:    del = old_fn/fn;
        -:  701:    
        -:  702:    if(fabs(del - 1.0) < 10.0*GSL_DBL_EPSILON) break;
        -:  703:  }
        -:  704:
        -:  705:  *result = fn;
        -:  706:  if(n == maxiter)
        -:  707:    GSL_ERROR ("error", GSL_EMAXITER);
        -:  708:  else
        -:  709:    return GSL_SUCCESS;
        -:  710:}
        -:  711:#endif /* 0 */
        -:  712:
        -:  713:
        -:  714:/* 1F1(a,b,x)
        -:  715: * |a| <= 1, b > 0
        -:  716: */
        -:  717:static
        -:  718:int
function hyperg_1F1_small_a_bgt0 called 0 returned 0% blocks executed 0%
    #####:  719:hyperg_1F1_small_a_bgt0(const double a, const double b, const double x, gsl_sf_result * result)
        -:  720:{
    #####:  721:  const double bma = b-a;
    #####:  722:  const double oma = 1.0-a;
    #####:  723:  const double ap1mb = 1.0+a-b;
    #####:  724:  const double abs_bma = fabs(bma);
    #####:  725:  const double abs_oma = fabs(oma);
    #####:  726:  const double abs_ap1mb = fabs(ap1mb);
        -:  727:
    #####:  728:  const double ax = fabs(x);
        -:  729:
    #####:  730:  if(a == 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  731:    result->val = 1.0;
    #####:  732:    result->err = 0.0;
    #####:  733:    return GSL_SUCCESS;
        -:  734:  }
    #####:  735:  else if(a == 1.0 && b >= 1.0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  736:    return hyperg_1F1_1(b, x, result);
        -:  737:  }
    #####:  738:  else if(a == -1.0) {
branch  0 never executed
branch  1 never executed
    #####:  739:    result->val  = 1.0 + a/b * x;
    #####:  740:    result->err  = GSL_DBL_EPSILON * (1.0 + fabs(a/b * x));
    #####:  741:    result->err += 2.0 * GSL_DBL_EPSILON * fabs(result->val);
    #####:  742:    return GSL_SUCCESS;
        -:  743:  }
    #####:  744:  else if(b >= 1.4*ax) {
branch  0 never executed
branch  1 never executed
    #####:  745:    return gsl_sf_hyperg_1F1_series_e(a, b, x, result);
        -:  746:  }
    #####:  747:  else if(x > 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  748:    if(x > 100.0 && abs_bma*abs_oma < 0.5*x) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  749:      return hyperg_1F1_asymp_posx(a, b, x, result);
        -:  750:    }
    #####:  751:    else if(b < 5.0e+06) {
branch  0 never executed
branch  1 never executed
        -:  752:      /* Recurse backward on b from
        -:  753:       * a suitably high point.
        -:  754:       */
    #####:  755:      const double b_del = ceil(1.4*x-b) + 1.0;
    #####:  756:      double bp = b + b_del;
        -:  757:      gsl_sf_result r_Mbp1;
        -:  758:      gsl_sf_result r_Mb;
        -:  759:      double Mbp1;
        -:  760:      double Mb;
        -:  761:      double Mbm1;
    #####:  762:      int stat_0 = gsl_sf_hyperg_1F1_series_e(a, bp+1.0, x, &r_Mbp1);
    #####:  763:      int stat_1 = gsl_sf_hyperg_1F1_series_e(a, bp,     x, &r_Mb);
    #####:  764:      const double err_rat = fabs(r_Mbp1.err/r_Mbp1.val) + fabs(r_Mb.err/r_Mb.val);
    #####:  765:      Mbp1 = r_Mbp1.val;
    #####:  766:      Mb   = r_Mb.val;
    #####:  767:      while(bp > b+0.1) {
branch  0 never executed
branch  1 never executed
        -:  768:        /* Do backward recursion. */
    #####:  769:        Mbm1 = ((x+bp-1.0)*Mb - x*(bp-a)/bp*Mbp1)/(bp-1.0);
    #####:  770:        bp -= 1.0;
    #####:  771:        Mbp1 = Mb;
    #####:  772:        Mb   = Mbm1;
        -:  773:      }
    #####:  774:      result->val  = Mb;
    #####:  775:      result->err  = err_rat * (fabs(b_del)+1.0) * fabs(Mb);
    #####:  776:      result->err += 2.0 * GSL_DBL_EPSILON * fabs(Mb);
    #####:  777:      return GSL_ERROR_SELECT_2(stat_0, stat_1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  778:    }
    #####:  779:    else if (fabs(x) < fabs(b) && fabs(a*x) < sqrt(fabs(b)) * fabs(b-x)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  780:      return hyperg_1F1_largebx(a, b, x, result);
        -:  781:    } else {
    #####:  782:      return hyperg_1F1_large2bm4a(a, b, x, result);
        -:  783:    }
        -:  784:  }
        -:  785:  else {
        -:  786:    /* x < 0 and b not large compared to |x|
        -:  787:     */
    #####:  788:    if(ax < 10.0 && b < 10.0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  789:      return gsl_sf_hyperg_1F1_series_e(a, b, x, result);
        -:  790:    }
    #####:  791:    else if(ax >= 100.0 && GSL_MAX(abs_ap1mb,1.0) < 0.99*ax) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  792:      return hyperg_1F1_asymp_negx(a, b, x, result);
        -:  793:    }
        -:  794:    else {
    #####:  795:      return hyperg_1F1_luke(a, b, x, result);
        -:  796:    }
        -:  797:  }
    #####:  798:}
        -:  799:
        -:  800:
        -:  801:/* 1F1(b+eps,b,x)
        -:  802: * |eps|<=1, b > 0
        -:  803: */
        -:  804:static
        -:  805:int
function hyperg_1F1_beps_bgt0 called 0 returned 0% blocks executed 0%
    #####:  806:hyperg_1F1_beps_bgt0(const double eps, const double b, const double x, gsl_sf_result * result)
        -:  807:{
    #####:  808:  if(b > fabs(x) && fabs(eps) < GSL_SQRT_DBL_EPSILON) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  809:    /* If b-a is very small and x/b is not too large we can
        -:  810:     * use this explicit approximation.
        -:  811:     *
        -:  812:     * 1F1(b+eps,b,x) = exp(ax/b) (1 - eps x^2 (v2 + v3 x + ...) + ...)
        -:  813:     *
        -:  814:     *   v2 = a/(2b^2(b+1))
        -:  815:     *   v3 = a(b-2a)/(3b^3(b+1)(b+2))
        -:  816:     *   ...
        -:  817:     *
        -:  818:     * See [Luke, Mathematical Functions and Their Approximations, p.292]
        -:  819:     *
        -:  820:     * This cannot be used for b near a negative integer or zero.
        -:  821:     * Also, if x/b is large the deviation from exp(x) behaviour grows.
        -:  822:     */
    #####:  823:    double a = b + eps;
        -:  824:    gsl_sf_result exab;
    #####:  825:    int stat_e = gsl_sf_exp_e(a*x/b, &exab);
    #####:  826:    double v2 = a/(2.0*b*b*(b+1.0));
    #####:  827:    double v3 = a*(b-2.0*a)/(3.0*b*b*b*(b+1.0)*(b+2.0));
    #####:  828:    double v  = v2 + v3 * x;
    #####:  829:    double f  = (1.0 - eps*x*x*v);
    #####:  830:    result->val  = exab.val * f;
    #####:  831:    result->err  = exab.err * fabs(f);
    #####:  832:    result->err += fabs(exab.val) * GSL_DBL_EPSILON * (1.0 + fabs(eps*x*x*v));
    #####:  833:    result->err += 4.0 * GSL_DBL_EPSILON * fabs(result->val);
    #####:  834:    return stat_e;
        -:  835:  }
        -:  836:  else {
        -:  837:    /* Otherwise use a Kummer transformation to reduce
        -:  838:     * it to the small a case.
        -:  839:     */
        -:  840:    gsl_sf_result Kummer_1F1;
    #####:  841:    int stat_K = hyperg_1F1_small_a_bgt0(-eps, b, -x, &Kummer_1F1);
    #####:  842:    if(Kummer_1F1.val != 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  843:      int stat_e = gsl_sf_exp_mult_err_e(x, 2.0*GSL_DBL_EPSILON*fabs(x),
    #####:  844:                                            Kummer_1F1.val, Kummer_1F1.err,
    #####:  845:                                            result);
    #####:  846:      return GSL_ERROR_SELECT_2(stat_e, stat_K);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  847:    }
        -:  848:    else {
    #####:  849:      result->val = 0.0;
    #####:  850:      result->err = 0.0;
    #####:  851:      return stat_K;
        -:  852:    }
        -:  853:  }
    #####:  854:}
        -:  855:
        -:  856:
        -:  857:/* 1F1(a,2a,x) = Gamma(a + 1/2) E(x) (|x|/4)^(-a+1/2) scaled_I(a-1/2,|x|/2)
        -:  858: *
        -:  859: * E(x) = exp(x) x > 0
        -:  860: *      = 1      x < 0
        -:  861: *
        -:  862: * a >= 1/2
        -:  863: */
        -:  864:static
        -:  865:int
function hyperg_1F1_beq2a_pos called 0 returned 0% blocks executed 0%
    #####:  866:hyperg_1F1_beq2a_pos(const double a, const double x, gsl_sf_result * result)
        -:  867:{
    #####:  868:  if(x == 0.0) {
branch  0 never executed
branch  1 never executed
    #####:  869:    result->val = 1.0;
    #####:  870:    result->err = 0.0;
    #####:  871:    return GSL_SUCCESS;
        -:  872:  }
        -:  873:  else {
        -:  874:    gsl_sf_result I;
    #####:  875:    int stat_I = gsl_sf_bessel_Inu_scaled_e(a-0.5, 0.5*fabs(x), &I);
        -:  876:    gsl_sf_result lg;
    #####:  877:    int stat_g = gsl_sf_lngamma_e(a + 0.5, &lg);
    #####:  878:    double ln_term   = (0.5-a)*log(0.25*fabs(x));
    #####:  879:    double lnpre_val = lg.val + GSL_MAX_DBL(x,0.0) + ln_term;
branch  0 never executed
branch  1 never executed
    #####:  880:    double lnpre_err = lg.err + GSL_DBL_EPSILON * (fabs(ln_term) + fabs(x));
    #####:  881:    int stat_e = gsl_sf_exp_mult_err_e(lnpre_val, lnpre_err,
    #####:  882:                                          I.val, I.err,
    #####:  883:                                          result);
    #####:  884:    return GSL_ERROR_SELECT_3(stat_e, stat_g, stat_I);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  885:  }
    #####:  886:}
        -:  887:
        -:  888:
        -:  889:/* Determine middle parts of diagonal recursion along b=2a
        -:  890: * from two endpoints, i.e.
        -:  891: *
        -:  892: * given:  M(a,b)      and  M(a+1,b+2)
        -:  893: * get:    M(a+1,b+1)  and  M(a,b+1)
        -:  894: */
        -:  895:#if 0
        -:  896:inline
        -:  897:static
        -:  898:int
        -:  899:hyperg_1F1_diag_step(const double a, const double b, const double x,
        -:  900:                     const double Mab, const double Map1bp2,
        -:  901:                     double * Map1bp1, double * Mabp1)
        -:  902:{
        -:  903:  if(a == b) {
        -:  904:    *Map1bp1 = Mab;
        -:  905:    *Mabp1   = Mab - x/(b+1.0) * Map1bp2;
        -:  906:  }
        -:  907:  else {
        -:  908:    *Map1bp1 = Mab - x * (a-b)/(b*(b+1.0)) * Map1bp2;
        -:  909:    *Mabp1   = (a * *Map1bp1 - b * Mab)/(a-b);
        -:  910:  }
        -:  911:  return GSL_SUCCESS;
        -:  912:}
        -:  913:#endif /* 0 */
        -:  914:
        -:  915:
        -:  916:/* Determine endpoint of diagonal recursion.
        -:  917: *
        -:  918: * given:  M(a,b)    and  M(a+1,b+2)
        -:  919: * get:    M(a+1,b)  and  M(a+1,b+1)
        -:  920: */
        -:  921:#if 0
        -:  922:inline
        -:  923:static
        -:  924:int
        -:  925:hyperg_1F1_diag_end_step(const double a, const double b, const double x,
        -:  926:                         const double Mab, const double Map1bp2,
        -:  927:                         double * Map1b, double * Map1bp1)
        -:  928:{
        -:  929:  *Map1bp1 = Mab - x * (a-b)/(b*(b+1.0)) * Map1bp2;
        -:  930:  *Map1b   = Mab + x/b * *Map1bp1;
        -:  931:  return GSL_SUCCESS;
        -:  932:}
        -:  933:#endif /* 0 */
        -:  934:
        -:  935:
        -:  936:/* Handle the case of a and b both positive integers.
        -:  937: * Assumes a > 0 and b > 0.
        -:  938: */
        -:  939:static
        -:  940:int
function hyperg_1F1_ab_posint called 0 returned 0% blocks executed 0%
    #####:  941:hyperg_1F1_ab_posint(const int a, const int b, const double x, gsl_sf_result * result)
        -:  942:{
    #####:  943:  double ax = fabs(x);
        -:  944:
    #####:  945:  if(a == b) {
branch  0 never executed
branch  1 never executed
    #####:  946:    return gsl_sf_exp_e(x, result);             /* 1F1(a,a,x) */
        -:  947:  }
    #####:  948:  else if(a == 1) {
branch  0 never executed
branch  1 never executed
    #####:  949:    return gsl_sf_exprel_n_e(b-1, x, result);   /* 1F1(1,b,x) */
        -:  950:  }
    #####:  951:  else if(b == a + 1) {
branch  0 never executed
branch  1 never executed
        -:  952:    gsl_sf_result K;
    #####:  953:    int stat_K = gsl_sf_exprel_n_e(a, -x, &K);  /* 1F1(1,1+a,-x) */
    #####:  954:    int stat_e = gsl_sf_exp_mult_err_e(x, 2.0 * GSL_DBL_EPSILON * fabs(x),
    #####:  955:                                          K.val, K.err,
    #####:  956:                                          result);
    #####:  957:    return GSL_ERROR_SELECT_2(stat_e, stat_K);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  958:  }
    #####:  959:  else if(a == b + 1) {
branch  0 never executed
branch  1 never executed
        -:  960:    gsl_sf_result ex;
    #####:  961:    int stat_e = gsl_sf_exp_e(x, &ex);
    #####:  962:    result->val  = ex.val * (1.0 + x/b);
    #####:  963:    result->err  = ex.err * (1.0 + x/b);
    #####:  964:    result->err += ex.val * GSL_DBL_EPSILON * (1.0 + fabs(x/b));
    #####:  965:    result->err += 2.0 * GSL_DBL_EPSILON * fabs(result->val);
    #####:  966:    return stat_e;
        -:  967:  }
    #####:  968:  else if(a == b + 2) {
branch  0 never executed
branch  1 never executed
        -:  969:    gsl_sf_result ex;
    #####:  970:    int stat_e = gsl_sf_exp_e(x, &ex);
    #####:  971:    double poly  = (1.0 + x/b*(2.0 + x/(b+1.0)));
    #####:  972:    result->val  = ex.val * poly;
    #####:  973:    result->err  = ex.err * fabs(poly);
    #####:  974:    result->err += ex.val * GSL_DBL_EPSILON * (1.0 + fabs(x/b) * (2.0 + fabs(x/(b+1.0))));
    #####:  975:    result->err += 2.0 * GSL_DBL_EPSILON * fabs(result->val);
    #####:  976:    return stat_e;
        -:  977:  }
    #####:  978:  else if(b == 2*a) {
branch  0 never executed
branch  1 never executed
    #####:  979:    return hyperg_1F1_beq2a_pos(a, x, result);  /* 1F1(a,2a,x) */
        -:  980:  }
    #####:  981:  else if(   ( b < 10 && a < 10 && ax < 5.0 )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:  982:          || ( b > a*ax )
branch  0 never executed
branch  1 never executed
    #####:  983:          || ( b > a && ax < 5.0 )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  984:    ) {
    #####:  985:    return gsl_sf_hyperg_1F1_series_e(a, b, x, result);
        -:  986:  }
    #####:  987:  else if(b > a && b >= 2*a + x) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  988:    /* Use the Gautschi CF series, then
        -:  989:     * recurse backward to a=0 for normalization.
        -:  990:     * This will work for either sign of x.
        -:  991:     */
        -:  992:    double rap;
    #####:  993:    int stat_CF1 = hyperg_1F1_CF1_p_ser(a, b, x, &rap);
    #####:  994:    double ra = 1.0 + x/a * rap;
    #####:  995:    double Ma   = GSL_SQRT_DBL_MIN;
    #####:  996:    double Map1 = ra * Ma;
    #####:  997:    double Mnp1 = Map1;
    #####:  998:    double Mn   = Ma;
        -:  999:    double Mnm1;
        -: 1000:    int n;
    #####: 1001:    for(n=a; n>0; n--) {
branch  0 never executed
branch  1 never executed
    #####: 1002:      Mnm1 = (n * Mnp1 - (2*n-b+x) * Mn) / (b-n);
    #####: 1003:      Mnp1 = Mn;
    #####: 1004:      Mn   = Mnm1;
    #####: 1005:    }
    #####: 1006:    result->val = Ma/Mn;
    #####: 1007:    result->err = 2.0 * GSL_DBL_EPSILON * (fabs(a) + 1.0) * fabs(Ma/Mn);
    #####: 1008:    return stat_CF1;
        -: 1009:  }
    #####: 1010:  else if(b > a && b < 2*a + x && b > x) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1011:    /* Use the Gautschi series representation of
        -: 1012:     * the continued fraction. Then recurse forward
        -: 1013:     * to the a=b line for normalization. This will
        -: 1014:     * work for either sign of x, although we do need
        -: 1015:     * to check for b > x, for when x is positive.
        -: 1016:     */
        -: 1017:    double rap;
    #####: 1018:    int stat_CF1 = hyperg_1F1_CF1_p_ser(a, b, x, &rap);
    #####: 1019:    double ra = 1.0 + x/a * rap;
        -: 1020:    gsl_sf_result ex;
        -: 1021:    int stat_ex;
        -: 1022:
    #####: 1023:    double Ma   = GSL_SQRT_DBL_MIN;
    #####: 1024:    double Map1 = ra * Ma;
    #####: 1025:    double Mnm1 = Ma;
    #####: 1026:    double Mn   = Map1;
        -: 1027:    double Mnp1;
        -: 1028:    int n;
    #####: 1029:    for(n=a+1; n<b; n++) {
branch  0 never executed
branch  1 never executed
    #####: 1030:      Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
    #####: 1031:      Mnm1 = Mn;
    #####: 1032:      Mn   = Mnp1;
    #####: 1033:    }
        -: 1034:
    #####: 1035:    stat_ex = gsl_sf_exp_e(x, &ex);  /* 1F1(b,b,x) */
    #####: 1036:    result->val  = ex.val * Ma/Mn;
    #####: 1037:    result->err  = ex.err * fabs(Ma/Mn);
    #####: 1038:    result->err += 4.0 * GSL_DBL_EPSILON * (fabs(b-a)+1.0) * fabs(result->val);
    #####: 1039:    return GSL_ERROR_SELECT_2(stat_ex, stat_CF1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1040:  }
    #####: 1041:  else if(x >= 0.0) {
branch  0 never executed
branch  1 never executed
        -: 1042:
    #####: 1043:    if(b < a) {
branch  0 never executed
branch  1 never executed
        -: 1044:      /* The point b,b is below the b=2a+x line.
        -: 1045:       * Forward recursion on a from b,b+1 is possible.
        -: 1046:       * Note that a > b + 1 as well, since we already tried a = b + 1.
        -: 1047:       */
    #####: 1048:      if(x + log(fabs(x/b)) < GSL_LOG_DBL_MAX-2.0) {
branch  0 never executed
branch  1 never executed
    #####: 1049:        double ex = exp(x);
        -: 1050:        int n;
    #####: 1051:        double Mnm1 = ex;                 /* 1F1(b,b,x)   */
    #####: 1052:        double Mn   = ex * (1.0 + x/b);   /* 1F1(b+1,b,x) */
        -: 1053:        double Mnp1;
    #####: 1054:        for(n=b+1; n<a; n++) {
branch  0 never executed
branch  1 never executed
    #####: 1055:          Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
    #####: 1056:          Mnm1 = Mn;
    #####: 1057:          Mn   = Mnp1;
    #####: 1058:        }
    #####: 1059:        result->val  = Mn;
    #####: 1060:        result->err  = (x + 1.0) * GSL_DBL_EPSILON * fabs(Mn);
    #####: 1061:        result->err *= fabs(a-b)+1.0;
    #####: 1062:        return GSL_SUCCESS;
        -: 1063:      }
        -: 1064:      else {
    #####: 1065:        OVERFLOW_ERROR(result);
        -: 1066:      }
    #####: 1067:    }
        -: 1068:    else {
        -: 1069:      /* b > a
        -: 1070:       * b < 2a + x 
        -: 1071:       * b <= x (otherwise we would have finished above)
        -: 1072:       *
        -: 1073:       * Gautschi anomalous convergence region. However, we can
        -: 1074:       * recurse forward all the way from a=0,1 because we are
        -: 1075:       * always underneath the b=2a+x line.
        -: 1076:       */
        -: 1077:      gsl_sf_result r_Mn;
    #####: 1078:      double Mnm1 = 1.0;    /* 1F1(0,b,x) */
        -: 1079:      double Mn;            /* 1F1(1,b,x)  */
        -: 1080:      double Mnp1;
        -: 1081:      int n;
    #####: 1082:      gsl_sf_exprel_n_e(b-1, x, &r_Mn);
    #####: 1083:      Mn = r_Mn.val;
    #####: 1084:      for(n=1; n<a; n++) {
branch  0 never executed
branch  1 never executed
    #####: 1085:        Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
    #####: 1086:        Mnm1 = Mn;
    #####: 1087:        Mn   = Mnp1;
    #####: 1088:      }
    #####: 1089:      result->val  = Mn;
    #####: 1090:      result->err  = fabs(Mn) * (1.0 + fabs(a)) * fabs(r_Mn.err / r_Mn.val);
    #####: 1091:      result->err += 2.0 * GSL_DBL_EPSILON * fabs(Mn);
    #####: 1092:      return GSL_SUCCESS;
        -: 1093:    }
    #####: 1094:  }
        -: 1095:  else {
        -: 1096:    /* x < 0
        -: 1097:     * b < a (otherwise we would have tripped one of the above)
        -: 1098:     */
        -: 1099:
    #####: 1100:    if(a <= 0.5*(b-x) || a >= -x) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1101:      /* Gautschi continued fraction is in the anomalous region,
        -: 1102:       * so we must find another way. We recurse down in b,
        -: 1103:       * from the a=b line.
        -: 1104:       */
    #####: 1105:      double ex = exp(x);
    #####: 1106:      double Manp1 = ex;
    #####: 1107:      double Man   = ex * (1.0 + x/(a-1.0));
        -: 1108:      double Manm1;
        -: 1109:      int n;
    #####: 1110:      for(n=a-1; n>b; n--) {
branch  0 never executed
branch  1 never executed
    #####: 1111:        Manm1 = (-n*(1-n-x)*Man - x*(n-a)*Manp1)/(n*(n-1.0));
    #####: 1112:        Manp1 = Man;
    #####: 1113:        Man = Manm1;
    #####: 1114:      }
    #####: 1115:      result->val  = Man;
    #####: 1116:      result->err  = (fabs(x) + 1.0) * GSL_DBL_EPSILON * fabs(Man);
    #####: 1117:      result->err *= fabs(b-a)+1.0;
    #####: 1118:      return GSL_SUCCESS;
        -: 1119:    }
        -: 1120:    else {
        -: 1121:      /* Pick a0 such that b ~= 2a0 + x, then
        -: 1122:       * recurse down in b from a0,a0 to determine
        -: 1123:       * the values near the line b=2a+x. Then recurse
        -: 1124:       * forward on a from a0.
        -: 1125:       */
    #####: 1126:      int a0 = (int) ceil(0.5*(b-x));
        -: 1127:      double Ma0b;    /* M(a0,b)   */
        -: 1128:      double Ma0bp1;  /* M(a0,b+1) */
        -: 1129:      double Ma0p1b;  /* M(a0+1,b) */
        -: 1130:      double Mnm1;
        -: 1131:      double Mn;
        -: 1132:      double Mnp1;
        -: 1133:      int n;
        -: 1134:      {
    #####: 1135:        double ex = exp(x);
    #####: 1136:        double Ma0np1 = ex;
    #####: 1137:        double Ma0n   = ex * (1.0 + x/(a0-1.0));
        -: 1138:        double Ma0nm1;
    #####: 1139:        for(n=a0-1; n>b; n--) {
branch  0 never executed
branch  1 never executed
    #####: 1140:          Ma0nm1 = (-n*(1-n-x)*Ma0n - x*(n-a0)*Ma0np1)/(n*(n-1.0));
    #####: 1141:          Ma0np1 = Ma0n;
    #####: 1142:          Ma0n = Ma0nm1;
    #####: 1143:        }
    #####: 1144:        Ma0bp1 = Ma0np1;
    #####: 1145:        Ma0b   = Ma0n;
    #####: 1146:        Ma0p1b = (b*(a0+x)*Ma0b + x*(a0-b)*Ma0bp1)/(a0*b);
        -: 1147:      }
        -: 1148:
        -: 1149:      /* Initialise the recurrence correctly BJG */
        -: 1150:
    #####: 1151:      if (a0 >= a)
branch  0 never executed
branch  1 never executed
        -: 1152:        { 
    #####: 1153:          Mn = Ma0b;
    #####: 1154:        }
    #####: 1155:      else if (a0 + 1>= a)
branch  0 never executed
branch  1 never executed
        -: 1156:        {
    #####: 1157:          Mn = Ma0p1b;
    #####: 1158:        }
        -: 1159:      else
        -: 1160:        {
    #####: 1161:          Mnm1 = Ma0b;
    #####: 1162:          Mn   = Ma0p1b;
        -: 1163:
    #####: 1164:          for(n=a0+1; n<a; n++) {
branch  0 never executed
branch  1 never executed
    #####: 1165:            Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
    #####: 1166:            Mnm1 = Mn;
    #####: 1167:            Mn   = Mnp1;
    #####: 1168:          }
        -: 1169:        }
        -: 1170:
    #####: 1171:      result->val  = Mn;
    #####: 1172:      result->err  = (fabs(x) + 1.0) * GSL_DBL_EPSILON *  fabs(Mn);
    #####: 1173:      result->err *= fabs(b-a)+1.0;
    #####: 1174:      return GSL_SUCCESS;
        -: 1175:    }
        -: 1176:  }
    #####: 1177:}
        -: 1178:
        -: 1179:
        -: 1180:/* Evaluate a <= 0, a integer, cases directly. (Polynomial; Horner)
        -: 1181: * When the terms are all positive, this
        -: 1182: * must work. We will assume this here.
        -: 1183: */
        -: 1184:static
        -: 1185:int
function hyperg_1F1_a_negint_poly called 0 returned 0% blocks executed 0%
    #####: 1186:hyperg_1F1_a_negint_poly(const int a, const double b, const double x, gsl_sf_result * result)
        -: 1187:{
    #####: 1188:  if(a == 0) {
branch  0 never executed
branch  1 never executed
    #####: 1189:    result->val = 1.0;
    #####: 1190:    result->err = 1.0;
    #####: 1191:    return GSL_SUCCESS;
        -: 1192:  }
        -: 1193:  else {
    #####: 1194:    int N = -a;
    #####: 1195:    double poly = 1.0;
        -: 1196:    int k;
    #####: 1197:    for(k=N-1; k>=0; k--) {
branch  0 never executed
branch  1 never executed
    #####: 1198:      double t = (a+k)/(b+k) * (x/(k+1));
    #####: 1199:      double r = t + 1.0/poly;
    #####: 1200:      if(r > 0.9*GSL_DBL_MAX/poly) {
branch  0 never executed
branch  1 never executed
    #####: 1201:        OVERFLOW_ERROR(result);
    #####: 1202:      }
        -: 1203:      else {
    #####: 1204:        poly *= r;  /* P_n = 1 + t_n P_{n-1} */
        -: 1205:      }
    #####: 1206:    }
    #####: 1207:    result->val = poly;
    #####: 1208:    result->err = 2.0 * (sqrt(N) + 1.0) * GSL_DBL_EPSILON * fabs(poly);
    #####: 1209:    return GSL_SUCCESS;
        -: 1210:  }
    #####: 1211:}
        -: 1212:
        -: 1213:
        -: 1214:/* Evaluate negative integer a case by relation
        -: 1215: * to Laguerre polynomials. This is more general than
        -: 1216: * the direct polynomial evaluation, but is safe
        -: 1217: * for all values of x.
        -: 1218: *
        -: 1219: * 1F1(-n,b,x) = n!/(b)_n Laguerre[n,b-1,x]
        -: 1220: *             = n B(b,n) Laguerre[n,b-1,x]
        -: 1221: *
        -: 1222: * assumes b is not a negative integer
        -: 1223: */
        -: 1224:static
        -: 1225:int
function hyperg_1F1_a_negint_lag called 0 returned 0% blocks executed 0%
    #####: 1226:hyperg_1F1_a_negint_lag(const int a, const double b, const double x, gsl_sf_result * result)
        -: 1227:{
    #####: 1228:  const int n = -a;
        -: 1229:
        -: 1230:  gsl_sf_result lag;
    #####: 1231:  const int stat_l = gsl_sf_laguerre_n_e(n, b-1.0, x, &lag);
    #####: 1232:  if(b < 0.0) {
branch  0 never executed
branch  1 never executed
        -: 1233:    gsl_sf_result lnfact;
        -: 1234:    gsl_sf_result lng1;
        -: 1235:    gsl_sf_result lng2;
        -: 1236:    double s1, s2;
    #####: 1237:    const int stat_f  = gsl_sf_lnfact_e(n, &lnfact);
    #####: 1238:    const int stat_g1 = gsl_sf_lngamma_sgn_e(b + n, &lng1, &s1);
    #####: 1239:    const int stat_g2 = gsl_sf_lngamma_sgn_e(b, &lng2, &s2);
    #####: 1240:    const double lnpre_val = lnfact.val - (lng1.val - lng2.val);
    #####: 1241:    const double lnpre_err = lnfact.err + lng1.err + lng2.err
    #####: 1242:      + 2.0 * GSL_DBL_EPSILON * fabs(lnpre_val);
    #####: 1243:    const int stat_e = gsl_sf_exp_mult_err_e(lnpre_val, lnpre_err,
    #####: 1244:                                                s1*s2*lag.val, lag.err,
    #####: 1245:                                                result);
    #####: 1246:    return GSL_ERROR_SELECT_5(stat_e, stat_l, stat_g1, stat_g2, stat_f);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 1247:  }
        -: 1248:  else {
        -: 1249:    gsl_sf_result lnbeta;
    #####: 1250:    gsl_sf_lnbeta_e(b, n, &lnbeta);
    #####: 1251:    if(fabs(lnbeta.val) < 0.1) {
branch  0 never executed
branch  1 never executed
        -: 1252:      /* As we have noted, when B(x,y) is near 1,
        -: 1253:       * evaluating log(B(x,y)) is not accurate.
        -: 1254:       * Instead we evaluate B(x,y) directly.
        -: 1255:       */
    #####: 1256:      const double ln_term_val = log(1.25*n);
    #####: 1257:      const double ln_term_err = 2.0 * GSL_DBL_EPSILON * ln_term_val;
        -: 1258:      gsl_sf_result beta;
    #####: 1259:      int stat_b = gsl_sf_beta_e(b, n, &beta);
    #####: 1260:      int stat_e = gsl_sf_exp_mult_err_e(ln_term_val, ln_term_err,
    #####: 1261:                                            lag.val, lag.err,
    #####: 1262:                                            result);
    #####: 1263:      result->val *= beta.val/1.25;
    #####: 1264:      result->err *= beta.val/1.25;
    #####: 1265:      return GSL_ERROR_SELECT_3(stat_e, stat_l, stat_b);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1266:    }
        -: 1267:    else {
        -: 1268:      /* B(x,y) was not near 1, so it is safe to use
        -: 1269:       * the logarithmic values.
        -: 1270:       */
    #####: 1271:      const double ln_n = log(n);
    #####: 1272:      const double ln_term_val = lnbeta.val + ln_n;
    #####: 1273:      const double ln_term_err = lnbeta.err + 2.0 * GSL_DBL_EPSILON * fabs(ln_n);
    #####: 1274:      int stat_e = gsl_sf_exp_mult_err_e(ln_term_val, ln_term_err,
    #####: 1275:                                            lag.val, lag.err,
    #####: 1276:                                            result);
    #####: 1277:      return GSL_ERROR_SELECT_2(stat_e, stat_l);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1278:    }
        -: 1279:  }
    #####: 1280:}
        -: 1281:
        -: 1282:
        -: 1283:/* Handle negative integer a case for x > 0 and
        -: 1284: * generic b.
        -: 1285: *
        -: 1286: * Combine [Abramowitz+Stegun, 13.6.9 + 13.6.27]
        -: 1287: * M(-n,b,x) = (-1)^n / (b)_n U(-n,b,x) = n! / (b)_n Laguerre^(b-1)_n(x)
        -: 1288: */
        -: 1289:#if 0
        -: 1290:static
        -: 1291:int
        -: 1292:hyperg_1F1_a_negint_U(const int a, const double b, const double x, gsl_sf_result * result)
        -: 1293:{
        -: 1294:  const int n = -a;
        -: 1295:  const double sgn = ( GSL_IS_ODD(n) ? -1.0 : 1.0 );
        -: 1296:  double sgpoch;
        -: 1297:  gsl_sf_result lnpoch;
        -: 1298:  gsl_sf_result U;
        -: 1299:  const int stat_p = gsl_sf_lnpoch_sgn_e(b, n, &lnpoch, &sgpoch);
        -: 1300:  const int stat_U = gsl_sf_hyperg_U_e(-n, b, x, &U);
        -: 1301:  const int stat_e = gsl_sf_exp_mult_err_e(-lnpoch.val, lnpoch.err,
        -: 1302:                                              sgn * sgpoch * U.val, U.err,
        -: 1303:                                              result);
        -: 1304:  return GSL_ERROR_SELECT_3(stat_e, stat_U, stat_p);
        -: 1305:}
        -: 1306:#endif
        -: 1307:
        -: 1308:
        -: 1309:/* Assumes a <= -1,  b <= -1, and b <= a.
        -: 1310: */
        -: 1311:static
        -: 1312:int
function hyperg_1F1_ab_negint called 0 returned 0% blocks executed 0%
    #####: 1313:hyperg_1F1_ab_negint(const int a, const int b, const double x, gsl_sf_result * result)
        -: 1314:{
    #####: 1315:  if(x == 0.0) {
branch  0 never executed
branch  1 never executed
    #####: 1316:    result->val = 1.0;
    #####: 1317:    result->err = 0.0;
    #####: 1318:    return GSL_SUCCESS;
        -: 1319:  }
    #####: 1320:  else if(x > 0.0) {
branch  0 never executed
branch  1 never executed
    #####: 1321:    return hyperg_1F1_a_negint_poly(a, b, x, result);
        -: 1322:  }
        -: 1323:  else {
        -: 1324:    /* Apply a Kummer transformation to make x > 0 so
        -: 1325:     * we can evaluate the polynomial safely. Of course,
        -: 1326:     * this assumes b <= a, which must be true for
        -: 1327:     * a<0 and b<0, since otherwise the thing is undefined.
        -: 1328:     */
        -: 1329:    gsl_sf_result K;
    #####: 1330:    int stat_K = hyperg_1F1_a_negint_poly(b-a, b, -x, &K);
    #####: 1331:    int stat_e = gsl_sf_exp_mult_err_e(x, 2.0 * GSL_DBL_EPSILON * fabs(x),
    #####: 1332:                                          K.val, K.err,
    #####: 1333:                                          result);
    #####: 1334:    return GSL_ERROR_SELECT_2(stat_e, stat_K);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1335:  }
    #####: 1336:}
        -: 1337:
        -: 1338:
        -: 1339:/* [Abramowitz+Stegun, 13.1.3]
        -: 1340: *
        -: 1341: * M(a,b,x) = Gamma(1+a-b)/Gamma(2-b) x^(1-b) *
        -: 1342: *            { Gamma(b)/Gamma(a) M(1+a-b,2-b,x) - (b-1) U(1+a-b,2-b,x) }
        -: 1343: *
        -: 1344: * b not an integer >= 2
        -: 1345: * a-b not a negative integer
        -: 1346: */
        -: 1347:static
        -: 1348:int
function hyperg_1F1_U called 0 returned 0% blocks executed 0%
    #####: 1349:hyperg_1F1_U(const double a, const double b, const double x, gsl_sf_result * result)
        -: 1350:{
    #####: 1351:  const double bp = 2.0 - b;
    #####: 1352:  const double ap = a - b + 1.0;
        -: 1353:
        -: 1354:  gsl_sf_result lg_ap, lg_bp;
        -: 1355:  double sg_ap;
    #####: 1356:  int stat_lg0 = gsl_sf_lngamma_sgn_e(ap, &lg_ap, &sg_ap);
    #####: 1357:  int stat_lg1 = gsl_sf_lngamma_e(bp, &lg_bp);
    #####: 1358:  int stat_lg2 = GSL_ERROR_SELECT_2(stat_lg0, stat_lg1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1359:  double t1 = (bp-1.0) * log(x);
    #####: 1360:  double lnpre_val = lg_ap.val - lg_bp.val + t1;
    #####: 1361:  double lnpre_err = lg_ap.err + lg_bp.err + 2.0 * GSL_DBL_EPSILON * fabs(t1);
        -: 1362:
        -: 1363:  gsl_sf_result lg_2mbp, lg_1papmbp;
        -: 1364:  double sg_2mbp, sg_1papmbp;
    #####: 1365:  int stat_lg3 = gsl_sf_lngamma_sgn_e(2.0-bp,    &lg_2mbp,    &sg_2mbp);
    #####: 1366:  int stat_lg4 = gsl_sf_lngamma_sgn_e(1.0+ap-bp, &lg_1papmbp, &sg_1papmbp);
    #####: 1367:  int stat_lg5 = GSL_ERROR_SELECT_2(stat_lg3, stat_lg4);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1368:  double lnc1_val = lg_2mbp.val - lg_1papmbp.val;
    #####: 1369:  double lnc1_err = lg_2mbp.err + lg_1papmbp.err
    #####: 1370:                    + GSL_DBL_EPSILON * (fabs(lg_2mbp.val) + fabs(lg_1papmbp.val));
        -: 1371:
        -: 1372:  gsl_sf_result M;
        -: 1373:  gsl_sf_result_e10 U;
    #####: 1374:  int stat_F = gsl_sf_hyperg_1F1_e(ap, bp, x, &M);
    #####: 1375:  int stat_U = gsl_sf_hyperg_U_e10_e(ap, bp, x, &U);
    #####: 1376:  int stat_FU = GSL_ERROR_SELECT_2(stat_F, stat_U);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1377:
        -: 1378:  gsl_sf_result_e10 term_M;
    #####: 1379:  int stat_e0 = gsl_sf_exp_mult_err_e10_e(lnc1_val, lnc1_err,
    #####: 1380:                                             sg_2mbp*sg_1papmbp*M.val, M.err,
        -: 1381:                                             &term_M);
        -: 1382:
    #####: 1383:  const double ombp = 1.0 - bp;
    #####: 1384:  const double Uee_val = U.e10*M_LN10;
    #####: 1385:  const double Uee_err = 2.0 * GSL_DBL_EPSILON * fabs(Uee_val);
    #####: 1386:  const double Mee_val = term_M.e10*M_LN10;
    #####: 1387:  const double Mee_err = 2.0 * GSL_DBL_EPSILON * fabs(Mee_val);
        -: 1388:  int stat_e1;
        -: 1389:
        -: 1390:  /* Do a little dance with the exponential prefactors
        -: 1391:   * to avoid overflows in intermediate results.
        -: 1392:   */
    #####: 1393:  if(Uee_val > Mee_val) {
branch  0 never executed
branch  1 never executed
    #####: 1394:    const double factorM_val = exp(Mee_val-Uee_val);
    #####: 1395:    const double factorM_err = 2.0 * GSL_DBL_EPSILON * (fabs(Mee_val-Uee_val)+1.0) * factorM_val;
    #####: 1396:    const double inner_val = term_M.val*factorM_val - ombp*U.val;
    #####: 1397:    const double inner_err =
    #####: 1398:        term_M.err*factorM_val + fabs(ombp) * U.err
    #####: 1399:      + fabs(term_M.val) * factorM_err
    #####: 1400:      + GSL_DBL_EPSILON * (fabs(term_M.val*factorM_val) + fabs(ombp*U.val));
    #####: 1401:    stat_e1 = gsl_sf_exp_mult_err_e(lnpre_val+Uee_val, lnpre_err+Uee_err,
    #####: 1402:                                       sg_ap*inner_val, inner_err,
    #####: 1403:                                       result);
    #####: 1404:  }
        -: 1405:  else {
    #####: 1406:    const double factorU_val = exp(Uee_val - Mee_val);
    #####: 1407:    const double factorU_err = 2.0 * GSL_DBL_EPSILON * (fabs(Mee_val-Uee_val)+1.0) * factorU_val;
    #####: 1408:    const double inner_val = term_M.val - ombp*factorU_val*U.val;
    #####: 1409:    const double inner_err =
    #####: 1410:        term_M.err + fabs(ombp*factorU_val*U.err)
    #####: 1411:      + fabs(ombp*factorU_err*U.val)
    #####: 1412:      + GSL_DBL_EPSILON * (fabs(term_M.val) + fabs(ombp*factorU_val*U.val));
    #####: 1413:    stat_e1 = gsl_sf_exp_mult_err_e(lnpre_val+Mee_val, lnpre_err+Mee_err,
    #####: 1414:                                       sg_ap*inner_val, inner_err,
    #####: 1415:                                       result);
        -: 1416:  }
        -: 1417:
    #####: 1418:  return GSL_ERROR_SELECT_5(stat_e1, stat_e0, stat_FU, stat_lg5, stat_lg2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -: 1419:}
        -: 1420:
        -: 1421:
        -: 1422:/* Handle case of generic positive a, b.
        -: 1423: * Assumes b-a is not a negative integer.
        -: 1424: */
        -: 1425:static
        -: 1426:int
function hyperg_1F1_ab_pos called 0 returned 0% blocks executed 0%
    #####: 1427:hyperg_1F1_ab_pos(const double a, const double b,
        -: 1428:                  const double x,
        -: 1429:                  gsl_sf_result * result)
        -: 1430:{
    #####: 1431:  const double ax = fabs(x);
        -: 1432:
    #####: 1433:  if(   ( b < 10.0 && a < 10.0 && ax < 5.0 )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1434:     || ( b > a*ax )
branch  0 never executed
branch  1 never executed
    #####: 1435:     || ( b > a && ax < 5.0 )
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1436:    ) {
    #####: 1437:    return gsl_sf_hyperg_1F1_series_e(a, b, x, result);
        -: 1438:  }
    #####: 1439:  else if(   x < -100.0
branch  0 never executed
branch  1 never executed
    #####: 1440:          && GSL_MAX_DBL(fabs(a),1.0)*GSL_MAX_DBL(fabs(1.0+a-b),1.0) < 0.7*fabs(x)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1441:    ) {
        -: 1442:    /* Large negative x asymptotic.
        -: 1443:     */
    #####: 1444:    return hyperg_1F1_asymp_negx(a, b, x, result);
        -: 1445:  }
    #####: 1446:  else if(   x > 100.0
branch  0 never executed
branch  1 never executed
    #####: 1447:          && GSL_MAX_DBL(fabs(b-a),1.0)*GSL_MAX_DBL(fabs(1.0-a),1.0) < 0.7*fabs(x)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1448:    ) {
        -: 1449:    /* Large positive x asymptotic.
        -: 1450:     */
    #####: 1451:    return hyperg_1F1_asymp_posx(a, b, x, result);
        -: 1452:  }
    #####: 1453:  else if(fabs(b-a) <= 1.0) {
branch  0 never executed
branch  1 never executed
        -: 1454:    /* Directly handle b near a.
        -: 1455:     */
    #####: 1456:    return hyperg_1F1_beps_bgt0(a-b, b, x, result);  /* a = b + eps */
        -: 1457:  }
        -: 1458:
    #####: 1459:  else if(b > a && b >= 2*a + x) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1460:    /* Use the Gautschi CF series, then
        -: 1461:     * recurse backward to a near 0 for normalization.
        -: 1462:     * This will work for either sign of x.
        -: 1463:     */ 
        -: 1464:    double rap;
    #####: 1465:    int stat_CF1 = hyperg_1F1_CF1_p_ser(a, b, x, &rap);
    #####: 1466:    double ra = 1.0 + x/a * rap;
        -: 1467:
    #####: 1468:    double Ma   = GSL_SQRT_DBL_MIN;
    #####: 1469:    double Map1 = ra * Ma;
    #####: 1470:    double Mnp1 = Map1;
    #####: 1471:    double Mn   = Ma;
        -: 1472:    double Mnm1;
        -: 1473:    gsl_sf_result Mn_true;
        -: 1474:    int stat_Mt;
        -: 1475:    double n;
    #####: 1476:    for(n=a; n>0.5; n -= 1.0) {
branch  0 never executed
branch  1 never executed
    #####: 1477:      Mnm1 = (n * Mnp1 - (2.0*n-b+x) * Mn) / (b-n);
    #####: 1478:      Mnp1 = Mn;
    #####: 1479:      Mn   = Mnm1;
    #####: 1480:    }
        -: 1481:
    #####: 1482:    stat_Mt = hyperg_1F1_small_a_bgt0(n, b, x, &Mn_true);
        -: 1483:
    #####: 1484:    result->val  = (Ma/Mn) * Mn_true.val;
    #####: 1485:    result->err  = fabs(Ma/Mn) * Mn_true.err;
    #####: 1486:    result->err += 2.0 * GSL_DBL_EPSILON * (fabs(a)+1.0) * fabs(result->val);
    #####: 1487:    return GSL_ERROR_SELECT_2(stat_Mt, stat_CF1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1488:  }
    #####: 1489:  else if(b > a && b < 2*a + x && b > x) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1490:    /* Use the Gautschi series representation of
        -: 1491:     * the continued fraction. Then recurse forward
        -: 1492:     * to near the a=b line for normalization. This will
        -: 1493:     * work for either sign of x, although we do need
        -: 1494:     * to check for b > x, which is relevant when x is positive.
        -: 1495:     */
        -: 1496:    gsl_sf_result Mn_true;
        -: 1497:    int stat_Mt;
        -: 1498:    double rap;
    #####: 1499:    int stat_CF1 = hyperg_1F1_CF1_p_ser(a, b, x, &rap);
    #####: 1500:    double ra = 1.0 + x/a * rap;
    #####: 1501:    double Ma   = GSL_SQRT_DBL_MIN;
    #####: 1502:    double Mnm1 = Ma;
    #####: 1503:    double Mn   = ra * Mnm1;
        -: 1504:    double Mnp1;
        -: 1505:    double n;
    #####: 1506:    for(n=a+1.0; n<b-0.5; n += 1.0) {
branch  0 never executed
branch  1 never executed
    #####: 1507:      Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
    #####: 1508:      Mnm1 = Mn;
    #####: 1509:      Mn   = Mnp1;
    #####: 1510:    }
    #####: 1511:    stat_Mt = hyperg_1F1_beps_bgt0(n-b, b, x, &Mn_true);
    #####: 1512:    result->val  = Ma/Mn * Mn_true.val;
    #####: 1513:    result->err  = fabs(Ma/Mn) * Mn_true.err;
    #####: 1514:    result->err += 2.0 * GSL_DBL_EPSILON * (fabs(b-a)+1.0) * fabs(result->val);
    #####: 1515:    return GSL_ERROR_SELECT_2(stat_Mt, stat_CF1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1516:  }
    #####: 1517:  else if(x >= 0.0) {
branch  0 never executed
branch  1 never executed
        -: 1518:
    #####: 1519:    if(b < a) {
branch  0 never executed
branch  1 never executed
        -: 1520:      /* Forward recursion on a from a=b+eps-1,b+eps.
        -: 1521:       */
    #####: 1522:      double N   = floor(a-b);
    #####: 1523:      double eps = a - b - N;
        -: 1524:      gsl_sf_result r_M0;
        -: 1525:      gsl_sf_result r_M1;
    #####: 1526:      int stat_0 = hyperg_1F1_beps_bgt0(eps-1.0, b, x, &r_M0);
    #####: 1527:      int stat_1 = hyperg_1F1_beps_bgt0(eps,     b, x, &r_M1);
    #####: 1528:      double M0 = r_M0.val;
    #####: 1529:      double M1 = r_M1.val;
        -: 1530:
    #####: 1531:      double Mam1 = M0;
    #####: 1532:      double Ma   = M1;
        -: 1533:      double Map1;
        -: 1534:      double ap;
    #####: 1535:      double start_pair = fabs(M0) + fabs(M1);
    #####: 1536:      double minim_pair = GSL_DBL_MAX;
        -: 1537:      double pair_ratio;
    #####: 1538:      double rat_0 = fabs(r_M0.err/r_M0.val);
    #####: 1539:      double rat_1 = fabs(r_M1.err/r_M1.val);
    #####: 1540:      for(ap=b+eps; ap<a-0.1; ap += 1.0) {
branch  0 never executed
branch  1 never executed
    #####: 1541:        Map1 = ((b-ap)*Mam1 + (2.0*ap-b+x)*Ma)/ap;
    #####: 1542:        Mam1 = Ma;
    #####: 1543:        Ma   = Map1;
    #####: 1544:        minim_pair = GSL_MIN_DBL(fabs(Mam1) + fabs(Ma), minim_pair);
branch  0 never executed
branch  1 never executed
    #####: 1545:      }
    #####: 1546:      pair_ratio = start_pair/minim_pair;
    #####: 1547:      result->val  = Ma;
    #####: 1548:      result->err  = 2.0 * (rat_0 + rat_1 + GSL_DBL_EPSILON) * (fabs(b-a)+1.0) * fabs(Ma);
    #####: 1549:      result->err += 2.0 * (rat_0 + rat_1) * pair_ratio*pair_ratio * fabs(Ma);
    #####: 1550:      result->err += 2.0 * GSL_DBL_EPSILON * fabs(Ma);
    #####: 1551:      return GSL_ERROR_SELECT_2(stat_0, stat_1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1552:    }
        -: 1553:    else {
        -: 1554:      /* b > a
        -: 1555:       * b < 2a + x 
        -: 1556:       * b <= x
        -: 1557:       *
        -: 1558:       * Recurse forward on a from a=eps,eps+1.
        -: 1559:       */
    #####: 1560:      double eps = a - floor(a);
        -: 1561:      gsl_sf_result r_Mnm1;
        -: 1562:      gsl_sf_result r_Mn;
    #####: 1563:      int stat_0 = hyperg_1F1_small_a_bgt0(eps,     b, x, &r_Mnm1);
    #####: 1564:      int stat_1 = hyperg_1F1_small_a_bgt0(eps+1.0, b, x, &r_Mn);
    #####: 1565:      double Mnm1 = r_Mnm1.val;
    #####: 1566:      double Mn   = r_Mn.val;
        -: 1567:      double Mnp1;
        -: 1568:
        -: 1569:      double n;
    #####: 1570:      double start_pair = fabs(Mn) + fabs(Mnm1);
    #####: 1571:      double minim_pair = GSL_DBL_MAX;
        -: 1572:      double pair_ratio;
    #####: 1573:      double rat_0 = fabs(r_Mnm1.err/r_Mnm1.val);
    #####: 1574:      double rat_1 = fabs(r_Mn.err/r_Mn.val);
    #####: 1575:      for(n=eps+1.0; n<a-0.1; n++) {
branch  0 never executed
branch  1 never executed
    #####: 1576:        Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
    #####: 1577:        Mnm1 = Mn;
    #####: 1578:        Mn   = Mnp1;
    #####: 1579:        minim_pair = GSL_MIN_DBL(fabs(Mn) + fabs(Mnm1), minim_pair);
branch  0 never executed
branch  1 never executed
    #####: 1580:      }
    #####: 1581:      pair_ratio = start_pair/minim_pair;
    #####: 1582:      result->val  = Mn;
    #####: 1583:      result->err  = 2.0 * (rat_0 + rat_1 + GSL_DBL_EPSILON) * (fabs(a)+1.0) * fabs(Mn);
    #####: 1584:      result->err += 2.0 * (rat_0 + rat_1) * pair_ratio*pair_ratio * fabs(Mn);
    #####: 1585:      result->err += 2.0 * GSL_DBL_EPSILON * fabs(Mn);
    #####: 1586:      return GSL_ERROR_SELECT_2(stat_0, stat_1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1587:    }
        -: 1588:  }
        -: 1589:  else {
        -: 1590:    /* x < 0
        -: 1591:     * b < a
        -: 1592:     */
        -: 1593:
    #####: 1594:    if(a <= 0.5*(b-x) || a >= -x) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1595:      /* Recurse down in b, from near the a=b line, b=a+eps,a+eps-1.
        -: 1596:       */
    #####: 1597:      double N   = floor(a - b);
    #####: 1598:      double eps = 1.0 + N - a + b;
        -: 1599:      gsl_sf_result r_Manp1;
        -: 1600:      gsl_sf_result r_Man;
    #####: 1601:      int stat_0 = hyperg_1F1_beps_bgt0(-eps,    a+eps,     x, &r_Manp1);
    #####: 1602:      int stat_1 = hyperg_1F1_beps_bgt0(1.0-eps, a+eps-1.0, x, &r_Man);
    #####: 1603:      double Manp1 = r_Manp1.val;
    #####: 1604:      double Man   = r_Man.val;
        -: 1605:      double Manm1;
        -: 1606:
        -: 1607:      double n;
    #####: 1608:      double start_pair = fabs(Manp1) + fabs(Man);
    #####: 1609:      double minim_pair = GSL_DBL_MAX;
        -: 1610:      double pair_ratio;
    #####: 1611:      double rat_0 = fabs(r_Manp1.err/r_Manp1.val);
    #####: 1612:      double rat_1 = fabs(r_Man.err/r_Man.val);
    #####: 1613:      for(n=a+eps-1.0; n>b+0.1; n -= 1.0) {
branch  0 never executed
branch  1 never executed
    #####: 1614:        Manm1 = (-n*(1-n-x)*Man - x*(n-a)*Manp1)/(n*(n-1.0));
    #####: 1615:        Manp1 = Man;
    #####: 1616:        Man = Manm1;
    #####: 1617:        minim_pair = GSL_MIN_DBL(fabs(Manp1) + fabs(Man), minim_pair);
branch  0 never executed
branch  1 never executed
    #####: 1618:      }
        -: 1619:
        -: 1620:      /* FIXME: this is a nasty little hack; there is some
        -: 1621:         (transient?) instability in this recurrence for some
        -: 1622:         values. I can tell when it happens, which is when
        -: 1623:         this pair_ratio is large. But I do not know how to
        -: 1624:         measure the error in terms of it. I guessed quadratic
        -: 1625:         below, but it is probably worse than that.
        -: 1626:         */
    #####: 1627:      pair_ratio = start_pair/minim_pair;
    #####: 1628:      result->val  = Man;
    #####: 1629:      result->err  = 2.0 * (rat_0 + rat_1 + GSL_DBL_EPSILON) * (fabs(b-a)+1.0) * fabs(Man);
    #####: 1630:      result->err *= pair_ratio*pair_ratio + 1.0;
    #####: 1631:      return GSL_ERROR_SELECT_2(stat_0, stat_1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1632:    }
        -: 1633:    else {
        -: 1634:      /* Pick a0 such that b ~= 2a0 + x, then
        -: 1635:       * recurse down in b from a0,a0 to determine
        -: 1636:       * the values near the line b=2a+x. Then recurse
        -: 1637:       * forward on a from a0.
        -: 1638:       */
    #####: 1639:      double epsa = a - floor(a);
    #####: 1640:      double a0   = floor(0.5*(b-x)) + epsa;
    #####: 1641:      double N    = floor(a0 - b);
    #####: 1642:      double epsb = 1.0 + N - a0 + b;
        -: 1643:      double Ma0b;
        -: 1644:      double Ma0bp1;
        -: 1645:      double Ma0p1b;
        -: 1646:      int stat_a0;
        -: 1647:      double Mnm1;
        -: 1648:      double Mn;
        -: 1649:      double Mnp1;
        -: 1650:      double n;
        -: 1651:      double err_rat;
        -: 1652:      {
        -: 1653:        gsl_sf_result r_Ma0np1;
        -: 1654:        gsl_sf_result r_Ma0n;
    #####: 1655:        int stat_0 = hyperg_1F1_beps_bgt0(-epsb,    a0+epsb,     x, &r_Ma0np1);
    #####: 1656:        int stat_1 = hyperg_1F1_beps_bgt0(1.0-epsb, a0+epsb-1.0, x, &r_Ma0n);
    #####: 1657:        double Ma0np1 = r_Ma0np1.val;
    #####: 1658:        double Ma0n   = r_Ma0n.val;
        -: 1659:        double Ma0nm1;
        -: 1660:
    #####: 1661:        err_rat = fabs(r_Ma0np1.err/r_Ma0np1.val) + fabs(r_Ma0n.err/r_Ma0n.val);
        -: 1662:
    #####: 1663:        for(n=a0+epsb-1.0; n>b+0.1; n -= 1.0) {
branch  0 never executed
branch  1 never executed
    #####: 1664:          Ma0nm1 = (-n*(1-n-x)*Ma0n - x*(n-a0)*Ma0np1)/(n*(n-1.0));
    #####: 1665:          Ma0np1 = Ma0n;
    #####: 1666:          Ma0n = Ma0nm1;
    #####: 1667:        }
    #####: 1668:        Ma0bp1 = Ma0np1;
    #####: 1669:        Ma0b   = Ma0n;
    #####: 1670:        Ma0p1b = (b*(a0+x)*Ma0b+x*(a0-b)*Ma0bp1)/(a0*b); /* right-down hook */
    #####: 1671:        stat_a0 = GSL_ERROR_SELECT_2(stat_0, stat_1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1672:      }
        -: 1673:
        -: 1674:          
        -: 1675:      /* Initialise the recurrence correctly BJG */
        -: 1676:
    #####: 1677:      if (a0 >= a - 0.1)
branch  0 never executed
branch  1 never executed
        -: 1678:        { 
    #####: 1679:          Mn = Ma0b;
    #####: 1680:        }
    #####: 1681:      else if (a0 + 1>= a - 0.1)
branch  0 never executed
branch  1 never executed
        -: 1682:        {
    #####: 1683:          Mn = Ma0p1b;
    #####: 1684:        }
        -: 1685:      else
        -: 1686:        {
    #####: 1687:          Mnm1 = Ma0b;
    #####: 1688:          Mn   = Ma0p1b;
        -: 1689:
    #####: 1690:          for(n=a0+1.0; n<a-0.1; n += 1.0) {
branch  0 never executed
branch  1 never executed
    #####: 1691:            Mnp1 = ((b-n)*Mnm1 + (2*n-b+x)*Mn)/n;
    #####: 1692:            Mnm1 = Mn;
    #####: 1693:            Mn   = Mnp1;
    #####: 1694:          }
        -: 1695:        }
        -: 1696:
    #####: 1697:      result->val = Mn;
    #####: 1698:      result->err = (err_rat + GSL_DBL_EPSILON) * (fabs(b-a)+1.0) * fabs(Mn);
    #####: 1699:      return stat_a0;
        -: 1700:    }
        -: 1701:  }
    #####: 1702:}
        -: 1703:
        -: 1704:
        -: 1705:/* Assumes b != integer
        -: 1706: * Assumes a != integer when x > 0
        -: 1707: * Assumes b-a != neg integer when x < 0
        -: 1708: */
        -: 1709:static
        -: 1710:int
function hyperg_1F1_ab_neg called 0 returned 0% blocks executed 0%
    #####: 1711:hyperg_1F1_ab_neg(const double a, const double b, const double x,
        -: 1712:                  gsl_sf_result * result)
        -: 1713:{
    #####: 1714:  const double bma = b - a;
    #####: 1715:  const double abs_x = fabs(x);
    #####: 1716:  const double abs_a = fabs(a);
    #####: 1717:  const double abs_b = fabs(b);
    #####: 1718:  const double size_a = GSL_MAX(abs_a, 1.0);
branch  0 never executed
branch  1 never executed
    #####: 1719:  const double size_b = GSL_MAX(abs_b, 1.0);
branch  0 never executed
branch  1 never executed
    #####: 1720:  const int bma_integer = ( bma - floor(bma+0.5) < _1F1_INT_THRESHOLD );
        -: 1721:
    #####: 1722:  if(   (abs_a < 10.0 && abs_b < 10.0 && abs_x < 5.0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1723:     || (b > 0.8*GSL_MAX(fabs(a),1.0)*fabs(x))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1724:    ) {
    #####: 1725:    return gsl_sf_hyperg_1F1_series_e(a, b, x, result);
        -: 1726:  }
    #####: 1727:  else if(   x > 0.0
branch  0 never executed
branch  1 never executed
    #####: 1728:          && size_b > size_a
branch  0 never executed
branch  1 never executed
    #####: 1729:          && size_a*log(M_E*x/size_b) < GSL_LOG_DBL_EPSILON+7.0
branch  0 never executed
branch  1 never executed
        -: 1730:    ) {
        -: 1731:    /* Series terms are positive definite up until
        -: 1732:     * there is a sign change. But by then the
        -: 1733:     * terms are small due to the last condition.
        -: 1734:     */
    #####: 1735:    return gsl_sf_hyperg_1F1_series_e(a, b, x, result);
        -: 1736:  }
    #####: 1737:  else if(   (abs_x < 5.0 && fabs(bma) < 10.0 && abs_b < 10.0)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1738:          || (b > 0.8*GSL_MAX_DBL(fabs(bma),1.0)*abs_x)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1739:    ) {
        -: 1740:    /* Use Kummer transformation to render series safe.
        -: 1741:     */
        -: 1742:    gsl_sf_result Kummer_1F1;
    #####: 1743:    int stat_K = gsl_sf_hyperg_1F1_series_e(bma, b, -x, &Kummer_1F1);
    #####: 1744:    int stat_e = gsl_sf_exp_mult_err_e(x, GSL_DBL_EPSILON * fabs(x),
    #####: 1745:                                      Kummer_1F1.val, Kummer_1F1.err,
    #####: 1746:                                      result);
    #####: 1747:    return GSL_ERROR_SELECT_2(stat_e, stat_K);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1748:  }
    #####: 1749:  else if(   x < -30.0
branch  0 never executed
branch  1 never executed
    #####: 1750:          && GSL_MAX_DBL(fabs(a),1.0)*GSL_MAX_DBL(fabs(1.0+a-b),1.0) < 0.99*fabs(x)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1751:    ) {
        -: 1752:    /* Large negative x asymptotic.
        -: 1753:     * Note that we do not check if b-a is a negative integer.
        -: 1754:     */
    #####: 1755:    return hyperg_1F1_asymp_negx(a, b, x, result);
        -: 1756:  }
    #####: 1757:  else if(   x > 100.0
branch  0 never executed
branch  1 never executed
    #####: 1758:          && GSL_MAX_DBL(fabs(bma),1.0)*GSL_MAX_DBL(fabs(1.0-a),1.0) < 0.99*fabs(x)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1759:    ) {
        -: 1760:    /* Large positive x asymptotic.
        -: 1761:     * Note that we do not check if a is a negative integer.
        -: 1762:     */
    #####: 1763:    return hyperg_1F1_asymp_posx(a, b, x, result);
        -: 1764:  }
    #####: 1765:  else if(x > 0.0 && !(bma_integer && bma > 0.0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1766:    return hyperg_1F1_U(a, b, x, result);
        -: 1767:  }
        -: 1768:  else {
        -: 1769:    /* FIXME:  if all else fails, try the series... BJG */
    #####: 1770:    if (x < 0.0) {
branch  0 never executed
branch  1 never executed
        -: 1771:      /* Apply Kummer Transformation */
    #####: 1772:      int status = gsl_sf_hyperg_1F1_series_e(b-a, b, -x, result);
    #####: 1773:      double K_factor = exp(x);
    #####: 1774:      result->val *= K_factor;
    #####: 1775:      result->err *= K_factor;
    #####: 1776:      return status;
        -: 1777:    } else {
    #####: 1778:      int status = gsl_sf_hyperg_1F1_series_e(a, b, x, result);
    #####: 1779:      return status;
        -: 1780:    }
        -: 1781:
        -: 1782:    /* Sadness... */
        -: 1783:    /* result->val = 0.0; */
        -: 1784:    /* result->err = 0.0; */
        -: 1785:    /* GSL_ERROR ("error", GSL_EUNIMPL); */
        -: 1786:  }
    #####: 1787:}
        -: 1788:
        -: 1789:
        -: 1790:/*-*-*-*-*-*-*-*-*-*-*-* Functions with Error Codes *-*-*-*-*-*-*-*-*-*-*-*/
        -: 1791:
        -: 1792:int
function gsl_sf_hyperg_1F1_int_e called 1 returned 100% blocks executed 12%
        1: 1793:gsl_sf_hyperg_1F1_int_e(const int a, const int b, const double x, gsl_sf_result * result)
        -: 1794:{
        -: 1795:  /* CHECK_POINTER(result) */
        -: 1796:
        1: 1797:  if(x == 0.0) {
branch  0 taken 0
branch  1 taken 1
    #####: 1798:    result->val = 1.0;
    #####: 1799:    result->err = 0.0;
    #####: 1800:    return GSL_SUCCESS;
        -: 1801:  }
        1: 1802:  else if(a == b) {
branch  0 taken 0
branch  1 taken 1
    #####: 1803:    return gsl_sf_exp_e(x, result);
        -: 1804:  }
        1: 1805:  else if(b == 0) {
branch  0 taken 0
branch  1 taken 1
    #####: 1806:    DOMAIN_ERROR(result);
    #####: 1807:  }
        1: 1808:  else if(a == 0) {
branch  0 taken 1
branch  1 taken 0
        1: 1809:    result->val = 1.0;
        1: 1810:    result->err = 0.0;
        1: 1811:    return GSL_SUCCESS;
        -: 1812:  }
    #####: 1813:  else if(b < 0 && (a < b || a > 0)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1814:    /* Standard domain error due to singularity. */
    #####: 1815:    DOMAIN_ERROR(result);
    #####: 1816:  }
    #####: 1817:  else if(x > 100.0  && GSL_MAX_DBL(1.0,fabs(b-a))*GSL_MAX_DBL(1.0,fabs(1-a)) < 0.5 * x) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1818:    /* x -> +Inf asymptotic */
    #####: 1819:    return hyperg_1F1_asymp_posx(a, b, x, result);
        -: 1820:  }
    #####: 1821:  else if(x < -100.0 && GSL_MAX_DBL(1.0,fabs(a))*GSL_MAX_DBL(1.0,fabs(1+a-b)) < 0.5 * fabs(x)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 1822:    /* x -> -Inf asymptotic */
    #####: 1823:    return hyperg_1F1_asymp_negx(a, b, x, result);
        -: 1824:  }
    #####: 1825:  else if(a < 0 && b < 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1826:    return hyperg_1F1_ab_negint(a, b, x, result);
        -: 1827:  }
    #####: 1828:  else if(a < 0 && b > 0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1829:    /* Use Kummer to reduce it to the positive integer case.
        -: 1830:     * Note that b > a, strictly, since we already trapped b = a.
        -: 1831:     */
        -: 1832:    gsl_sf_result Kummer_1F1;
    #####: 1833:    int stat_K = hyperg_1F1_ab_posint(b-a, b, -x, &Kummer_1F1);
    #####: 1834:    int stat_e = gsl_sf_exp_mult_err_e(x, GSL_DBL_EPSILON * fabs(x),
    #####: 1835:                                      Kummer_1F1.val, Kummer_1F1.err,
    #####: 1836:                                      result); 
    #####: 1837:    return GSL_ERROR_SELECT_2(stat_e, stat_K);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1838:  }
        -: 1839:  else {
        -: 1840:    /* a > 0 and b > 0 */
    #####: 1841:    return hyperg_1F1_ab_posint(a, b, x, result);
        -: 1842:  }
        1: 1843:}
        -: 1844:
        -: 1845:
        -: 1846:int
function gsl_sf_hyperg_1F1_e called 0 returned 0% blocks executed 0%
    #####: 1847:gsl_sf_hyperg_1F1_e(const double a, const double b, const double x,
        -: 1848:                       gsl_sf_result * result
        -: 1849:                       )
        -: 1850:{
    #####: 1851:  const double bma = b - a;
    #####: 1852:  const double rinta = floor(a + 0.5);
    #####: 1853:  const double rintb = floor(b + 0.5);
    #####: 1854:  const double rintbma = floor(bma + 0.5);
    #####: 1855:  const int a_integer   = ( fabs(a-rinta) < _1F1_INT_THRESHOLD && rinta > INT_MIN && rinta < INT_MAX );
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1856:  const int b_integer   = ( fabs(b-rintb) < _1F1_INT_THRESHOLD && rintb > INT_MIN && rintb < INT_MAX );
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1857:  const int bma_integer = ( fabs(bma-rintbma) < _1F1_INT_THRESHOLD && rintbma > INT_MIN && rintbma < INT_MAX );
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1858:  const int b_neg_integer   = ( b < -0.1 && b_integer );
branch  0 never executed
branch  1 never executed
    #####: 1859:  const int a_neg_integer   = ( a < -0.1 && a_integer );
branch  0 never executed
branch  1 never executed
    #####: 1860:  const int bma_neg_integer = ( bma < -0.1 &&  bma_integer );
branch  0 never executed
branch  1 never executed
        -: 1861:
        -: 1862:  /* CHECK_POINTER(result) */
        -: 1863:
    #####: 1864:  if(x == 0.0) {
branch  0 never executed
branch  1 never executed
        -: 1865:    /* Testing for this before testing a and b
        -: 1866:     * is somewhat arbitrary. The result is that
        -: 1867:     * we have 1F1(a,0,0) = 1.
        -: 1868:     */
    #####: 1869:    result->val = 1.0;
    #####: 1870:    result->err = 0.0;
    #####: 1871:    return GSL_SUCCESS;
        -: 1872:  }
    #####: 1873:  else if(b == 0.0) {
branch  0 never executed
branch  1 never executed
    #####: 1874:    DOMAIN_ERROR(result);
    #####: 1875:  }
    #####: 1876:  else if(a == 0.0) {
branch  0 never executed
branch  1 never executed
    #####: 1877:    result->val = 1.0;
    #####: 1878:    result->err = 0.0;
    #####: 1879:    return GSL_SUCCESS;
        -: 1880:  }
    #####: 1881:  else if(a == b) {
branch  0 never executed
branch  1 never executed
        -: 1882:    /* case: a==b; exp(x)
        -: 1883:     * It's good to test exact equality now.
        -: 1884:     * We also test approximate equality later.
        -: 1885:     */
    #####: 1886:    return gsl_sf_exp_e(x, result);
    #####: 1887:  } else if(fabs(b) < _1F1_INT_THRESHOLD && fabs(a) < _1F1_INT_THRESHOLD) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1888:    /* a and b near zero: 1 + a/b (exp(x)-1)
        -: 1889:     */
        -: 1890:
        -: 1891:    /* Note that neither a nor b is zero, since
        -: 1892:     * we eliminated that with the above tests.
        -: 1893:     */
        -: 1894:    
        -: 1895:    gsl_sf_result exm1;
    #####: 1896:    int stat_e = gsl_sf_expm1_e(x, &exm1);
    #####: 1897:    double sa = ( a > 0.0 ? 1.0 : -1.0 );
    #####: 1898:    double sb = ( b > 0.0 ? 1.0 : -1.0 );
    #####: 1899:    double lnab = log(fabs(a/b)); /* safe */
        -: 1900:    gsl_sf_result hx;
    #####: 1901:    int stat_hx = gsl_sf_exp_mult_err_e(lnab, GSL_DBL_EPSILON * fabs(lnab),
    #####: 1902:                                        sa * sb * exm1.val, exm1.err,
        -: 1903:                                        &hx);
    #####: 1904:    result->val = (hx.val == GSL_DBL_MAX ? hx.val : 1.0 + hx.val);  /* FIXME: excessive paranoia ? what is DBL_MAX+1 ?*/
branch  0 never executed
branch  1 never executed
    #####: 1905:    result->err = hx.err;
    #####: 1906:    return GSL_ERROR_SELECT_2(stat_hx, stat_e);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1907:  } else if (fabs(b) < _1F1_INT_THRESHOLD && fabs(x*a) < 1) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1908:      /* b near zero and a not near zero
        -: 1909:       */
    #####: 1910:      const double m_arg = 1.0/(0.5*b);
        -: 1911:      gsl_sf_result F_renorm;
    #####: 1912:      int stat_F = hyperg_1F1_renorm_b0(a, x, &F_renorm);
    #####: 1913:      int stat_m = gsl_sf_multiply_err_e(m_arg, 2.0 * GSL_DBL_EPSILON * m_arg,
    #####: 1914:                                            0.5*F_renorm.val, 0.5*F_renorm.err,
    #####: 1915:                                            result);
    #####: 1916:      return GSL_ERROR_SELECT_2(stat_m, stat_F);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1917:  }
    #####: 1918:  else if(a_integer && b_integer) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1919:    /* Check for reduction to the integer case.
        -: 1920:     * Relies on the arbitrary "near an integer" test.
        -: 1921:     */
    #####: 1922:    return gsl_sf_hyperg_1F1_int_e((int)rinta, (int)rintb, x, result);
        -: 1923:  }
    #####: 1924:  else if(b_neg_integer && !(a_neg_integer && a > b)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1925:    /* Standard domain error due to
        -: 1926:     * uncancelled singularity.
        -: 1927:     */
    #####: 1928:    DOMAIN_ERROR(result);
    #####: 1929:  }
    #####: 1930:  else if(a_neg_integer) {
branch  0 never executed
branch  1 never executed
    #####: 1931:    return hyperg_1F1_a_negint_lag((int)rinta, b, x, result);
        -: 1932:  }
    #####: 1933:  else if(b > 0.0) {
branch  0 never executed
branch  1 never executed
    #####: 1934:    if(-1.0 <= a && a <= 1.0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1935:      /* Handle small a explicitly.
        -: 1936:       */
    #####: 1937:      return hyperg_1F1_small_a_bgt0(a, b, x, result);
        -: 1938:    }
    #####: 1939:    else if(bma_neg_integer) {
branch  0 never executed
branch  1 never executed
        -: 1940:      /* Catch this now, to avoid problems in the
        -: 1941:       * generic evaluation code.
        -: 1942:       */
        -: 1943:      gsl_sf_result Kummer_1F1;
    #####: 1944:      int stat_K = hyperg_1F1_a_negint_lag((int)rintbma, b, -x, &Kummer_1F1);
    #####: 1945:      int stat_e = gsl_sf_exp_mult_err_e(x, GSL_DBL_EPSILON * fabs(x),
    #####: 1946:                                            Kummer_1F1.val, Kummer_1F1.err,
    #####: 1947:                                            result);
    #####: 1948:      return GSL_ERROR_SELECT_2(stat_e, stat_K);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1949:    }
    #####: 1950:    else if(a < 0.0 && fabs(x) < 2*GSL_LOG_DBL_MAX) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1951:      /* Use Kummer to reduce it to the generic positive case.
        -: 1952:       * Note that b > a, strictly, since we already trapped b = a.
        -: 1953:       * Also b-(b-a)=a, and a is not a negative integer here,
        -: 1954:       * so the generic evaluation is safe.
        -: 1955:       */
        -: 1956:      gsl_sf_result Kummer_1F1;
    #####: 1957:      int stat_K = hyperg_1F1_ab_pos(b-a, b, -x, &Kummer_1F1);
    #####: 1958:      int stat_e = gsl_sf_exp_mult_err_e(x, GSL_DBL_EPSILON * fabs(x),
    #####: 1959:                                            Kummer_1F1.val, Kummer_1F1.err,
    #####: 1960:                                            result);
    #####: 1961:      return GSL_ERROR_SELECT_2(stat_e, stat_K);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1962:    }
    #####: 1963:    else if (a > 0) {
branch  0 never executed
branch  1 never executed
        -: 1964:      /* a > 0.0 */
    #####: 1965:      return hyperg_1F1_ab_pos(a, b, x, result);
        -: 1966:    } else {
    #####: 1967:      return gsl_sf_hyperg_1F1_series_e(a, b, x, result);
        -: 1968:    }
        -: 1969:  }
        -: 1970:  else {
        -: 1971:    /* b < 0.0 */
        -: 1972:
    #####: 1973:    if(bma_neg_integer && x < 0.0) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1974:      /* Handle this now to prevent problems
        -: 1975:       * in the generic evaluation.
        -: 1976:       */
        -: 1977:      gsl_sf_result K;
        -: 1978:      int stat_K;
        -: 1979:      int stat_e;
    #####: 1980:      if(a < 0.0) {
branch  0 never executed
branch  1 never executed
        -: 1981:        /* Kummer transformed version of safe polynomial.
        -: 1982:         * The condition a < 0 is equivalent to b < b-a,
        -: 1983:         * which is the condition required for the series
        -: 1984:         * to be positive definite here.
        -: 1985:         */
    #####: 1986:        stat_K = hyperg_1F1_a_negint_poly((int)rintbma, b, -x, &K);
    #####: 1987:      }
        -: 1988:      else {
        -: 1989:        /* Generic eval for negative integer a. */
    #####: 1990:        stat_K = hyperg_1F1_a_negint_lag((int)rintbma, b, -x, &K);
        -: 1991:      }
    #####: 1992:      stat_e = gsl_sf_exp_mult_err_e(x, GSL_DBL_EPSILON * fabs(x),
    #####: 1993:                                        K.val, K.err,
    #####: 1994:                                        result);
    #####: 1995:      return GSL_ERROR_SELECT_2(stat_e, stat_K);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1996:    }
    #####: 1997:    else if(a > 0.0) {
branch  0 never executed
branch  1 never executed
        -: 1998:      /* Use Kummer to reduce it to the generic negative case.
        -: 1999:       */
        -: 2000:      gsl_sf_result K;
    #####: 2001:      int stat_K = hyperg_1F1_ab_neg(b-a, b, -x, &K);
    #####: 2002:      int stat_e = gsl_sf_exp_mult_err_e(x, GSL_DBL_EPSILON * fabs(x),
    #####: 2003:                                            K.val, K.err,
    #####: 2004:                                            result);
    #####: 2005:      return GSL_ERROR_SELECT_2(stat_e, stat_K);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2006:    }
        -: 2007:    else {
    #####: 2008:      return hyperg_1F1_ab_neg(a, b, x, result);
        -: 2009:    }
        -: 2010:  }
    #####: 2011:}
        -: 2012:
        -: 2013:
        -: 2014:  
        -: 2015:#if 0  
        -: 2016:    /* Luke in the canonical case.
        -: 2017:   */
        -: 2018:  if(x < 0.0 && !a_neg_integer && !bma_neg_integer) {
        -: 2019:    double prec;
        -: 2020:    return hyperg_1F1_luke(a, b, x, result, &prec);
        -: 2021:  }
        -: 2022:
        -: 2023:
        -: 2024:  /* Luke with Kummer transformation.
        -: 2025:   */
        -: 2026:  if(x > 0.0 && !a_neg_integer && !bma_neg_integer) {
        -: 2027:    double prec;
        -: 2028:    double Kummer_1F1;
        -: 2029:    double ex;
        -: 2030:    int stat_F = hyperg_1F1_luke(b-a, b, -x, &Kummer_1F1, &prec);
        -: 2031:    int stat_e = gsl_sf_exp_e(x, &ex);
        -: 2032:    if(stat_F == GSL_SUCCESS && stat_e == GSL_SUCCESS) {
        -: 2033:      double lnr = log(fabs(Kummer_1F1)) + x;
        -: 2034:      if(lnr < GSL_LOG_DBL_MAX) {
        -: 2035:        *result = ex * Kummer_1F1;
        -: 2036:        return GSL_SUCCESS;
        -: 2037:      }
        -: 2038:      else {
        -: 2039:        *result = GSL_POSINF; 
        -: 2040:        GSL_ERROR ("overflow", GSL_EOVRFLW);
        -: 2041:      }
        -: 2042:    }
        -: 2043:    else if(stat_F != GSL_SUCCESS) {
        -: 2044:      *result = 0.0;
        -: 2045:      return stat_F;
        -: 2046:    }
        -: 2047:    else {
        -: 2048:      *result = 0.0;
        -: 2049:      return stat_e;
        -: 2050:    }
        -: 2051:  }
        -: 2052:#endif
        -: 2053:
        -: 2054:
        -: 2055:
        -: 2056:/*-*-*-*-*-*-*-*-*-* Functions w/ Natural Prototypes *-*-*-*-*-*-*-*-*-*-*/
        -: 2057:
        -: 2058:#include "../../gsl-2.6/specfunc/eval.h"
        -: 2059:
function gsl_sf_hyperg_1F1_int called 1 returned 100% blocks executed 57%
        1: 2060:double gsl_sf_hyperg_1F1_int(const int m, const int n, double x)
        -: 2061:{
        1: 2062:  EVAL_RESULT(gsl_sf_hyperg_1F1_int_e(m, n, x, &result));
branch  0 taken 0
branch  1 taken 1
        1: 2063:}
        -: 2064:
function gsl_sf_hyperg_1F1 called 0 returned 0% blocks executed 0%
    #####: 2065:double gsl_sf_hyperg_1F1(double a, double b, double x)
        -: 2066:{
    #####: 2067:  EVAL_RESULT(gsl_sf_hyperg_1F1_e(a, b, x, &result));
branch  0 never executed
branch  1 never executed
    #####: 2068:}
        -: 2069:
function main called 1 returned 100% blocks executed 100%
        1: 2070:int main(int argc, char *argv[]){
        -: 2071:    
        -: 2072:    
        -: 2073:    int m,n;
        -: 2074:    double a,b,x1,x2;
        -: 2075:    
        -: 2076:    char line[1024];
        -: 2077:    double data[410][3];
        1: 2078:    FILE* stream = fopen("10_100.csv", "r");
        1: 2079:    int i=0;
       21: 2080:    while (fgets(line, 1024, stream))//
branch  0 taken 20
branch  1 taken 1
        -: 2081:    {
       20: 2082:        int j = 0;
        -: 2083:        char *tok;
       20: 2084:        char* tmp = strdup(line);
       80: 2085:        for (tok = strtok(line, ","); tok && *tok; j++, tok = strtok(NULL, ",\n")){
branch  0 taken 60
branch  1 taken 20
branch  2 taken 60
branch  3 taken 20
       60: 2086:            data[i][j] = atof(tok);//
       60: 2087:        }//
       20: 2088:        i++;
       20: 2089:        free(tmp);
        -: 2090:    }
        1: 2091:    fclose(stream);//
        -: 2092:    int w;
        1: 2093:    w=atoi(argv[1]);
        1: 2094:    m = (int)data[w][0];
        1: 2095:    n = (int)data[w][1];
        -: 2096:    //a = data[w][0];
        -: 2097:    //b = data[w][1];
        1: 2098:    x1 = data[w][2];
        -: 2099:    //x2 = data[w][2];
        1: 2100:    printf("test%d:   m=%d, n=%d, x1=%f\n", w,m,n,x1);
        1: 2101:    printf("gsl_sf_hyperg_1F1_int  :%f\n", gsl_sf_hyperg_1F1_int(m,n,x1));
        -: 2102:    //printf("gsl_sf_hyperg_1F1  :%f\n", gsl_sf_hyperg_1F1(a,b,x2));
        -: 2103:
        1: 2104:    return 0;
        -: 2105:}
